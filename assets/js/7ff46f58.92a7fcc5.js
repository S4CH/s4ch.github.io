"use strict";(self.webpackChunkcyfun_me=self.webpackChunkcyfun_me||[]).push([[4831],{3905:(e,n,r)=>{r.d(n,{Zo:()=>o,kt:()=>m});var a=r(67294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function f(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var c=a.createContext({}),b=function(e){var n=a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},o=function(e){var n=b(e.components);return a.createElement(c.Provider,{value:n},e.children)},l="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},x=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,i=e.originalType,c=e.parentName,o=f(e,["components","mdxType","originalType","parentName"]),l=b(r),x=t,m=l["".concat(c,".").concat(x)]||l[x]||d[x]||i;return r?a.createElement(m,s(s({ref:n},o),{},{components:r})):a.createElement(m,s({ref:n},o))}));function m(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=r.length,s=new Array(i);s[0]=x;var f={};for(var c in n)hasOwnProperty.call(n,c)&&(f[c]=n[c]);f.originalType=e,f[l]="string"==typeof e?e:t,s[1]=f;for(var b=2;b<i;b++)s[b]=r[b];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}x.displayName="MDXCreateElement"},89104:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>f,toc:()=>b});var a=r(87462),t=(r(67294),r(3905));const i={},s="Reverse Engineering",f={unversionedId:"Tryhackme/Reverse Engineering/Reverse Engineering",id:"Tryhackme/Reverse Engineering/Reverse Engineering",title:"Reverse Engineering",description:"This room focuses on teaching the basics of assembly through reverse engineering",source:"@site/writeups/Tryhackme/Reverse Engineering/Reverse Engineering.md",sourceDirName:"Tryhackme/Reverse Engineering",slug:"/Tryhackme/Reverse Engineering/",permalink:"/writeups/Tryhackme/Reverse Engineering/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Revenge",permalink:"/writeups/Tryhackme/Revenge/"},next:{title:"Reversing ELF",permalink:"/writeups/Tryhackme/Reversing ELF/"}},c={},b=[{value:"\ud83d\udca2 We will cover  the topics",id:"-we-will-cover--the-topics",level:2},{value:"Task 1 Debugging and File Permission",id:"task-1-debugging-and-file-permission",level:2},{value:"Task 2 crackme1",id:"task-2-crackme1",level:2},{value:"Task 3 crackme2",id:"task-3-crackme2",level:2},{value:"Task 4 crackme3",id:"task-4-crackme3",level:2}],o={toc:b},l="wrapper";function d(e){let{components:n,...r}=e;return(0,t.kt)(l,(0,a.Z)({},o,r,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"reverse-engineering"},"Reverse Engineering"),(0,t.kt)("p",null,"This room focuses on teaching the basics of assembly through reverse engineering"),(0,t.kt)("h2",{id:"-we-will-cover--the-topics"},"\ud83d\udca2 We will cover  the topics"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Reverse Engineering")),(0,t.kt)("hr",null),(0,t.kt)("h2",{id:"task-1-debugging-and-file-permission"},"Task 1 Debugging and File Permission"),(0,t.kt)("p",null,"In this task, we'll be learning the basics of reverse engineering and assembly. Here are some important things to do before starting the task:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"These files have been compiled with the lowest level of optimisation on Unix based machines and are intended to be run on Linux/Mac."),(0,t.kt)("li",{parentName:"ul"},"Make sure you set up a debugger - it would be good to get comfortable with radare2 which can be downloaded from ",(0,t.kt)("a",{parentName:"li",href:"https://github.com/radare/radare2"},"here"),". You can also use other debuggers like gdb, which come installed in most Unix based operating systems."),(0,t.kt)("li",{parentName:"ul"},"When these files have been downloaded, change the permissions of these files using the command ",(0,t.kt)("inlineCode",{parentName:"li"},"chmod +x filename"))),(0,t.kt)("p",null,"These tasks will make use of crackme files. The objective of these files is to understand the assembly code to uncover the right password for the file."),(0,t.kt)("p",null,"Here are some of the important things you will learn in this course:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"If statements in assembly"),(0,t.kt)("li",{parentName:"ul"},"Loops in assembly"),(0,t.kt)("li",{parentName:"ul"},"standard function calls in assembly"),(0,t.kt)("li",{parentName:"ul"},"Calling Convention in assembly")),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"Set up debugger(if you haven't already)")),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"No answer needed")),(0,t.kt)("h2",{id:"task-2-crackme1"},"Task 2 crackme1"),(0,t.kt)("p",null,"This first crackme file will give you an introduction to if statements and basic function calling in assembly."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"kali@kali:~/CTFs/tryhackme/Reverse Engineering$ file crackme1.bin\ncrackme1.bin: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=3864320789154e8960133afdf58ddf65f6f8273d, not stripped\nkali@kali:~/CTFs/tryhackme/Reverse Engineering$ strings crackme1.bin\n\nenter password\npassword is correct\npassword is incorrect\nhax0r\n\n")),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"what is the correct password")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"kali@kali:~/CTFs/tryhackme/Reverse Engineering$ ./crackme1.bin\nenter password\nhax0r\npassword is correct\n")),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"hax0r")),(0,t.kt)("h2",{id:"task-3-crackme2"},"Task 3 crackme2"),(0,t.kt)("p",null,"This is the second crackme file - Unlike the first file, this will involve examining registers, how and where values are compared"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},'kali@kali:~/CTFs/tryhackme/Reverse Engineering$ r2 -d ./crackme2.bin\nProcess with PID 78763 started...\n= attach 78763 78763\nbin.baddr 0x55fb45bf4000\nUsing 0x55fb45bf4000\nasm.bits 64\nWarning: r_bin_file_hash: file exceeds bin.hashlimit\n[0x7f58df4df090]> aaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Check for objc references\n[x] Check for vtables\n[TOFIX: aaft can\'t run in debugger mode.ions (aaft)\n[x] Type matching analysis for all functions (aaft)\n[x] Propagate noreturn information\n[x] Use -AA or aaaa to perform additional experimental analysis.\n[0x7f58df4df090]> afl\n0x55fb45bf4610    1 42           entry0\n0x55fb45df4fe0    1 4124         reloc.__libc_start_main\n0x55fb45bf4640    4 50   -> 40   sym.deregister_tm_clones\n0x55fb45bf4680    4 66   -> 57   sym.register_tm_clones\n0x55fb45bf46d0    5 58   -> 51   entry.fini0\n0x55fb45bf4600    1 6            sym..plt.got\n0x55fb45bf4710    1 10           entry.init0\n0x55fb45bf4810    1 2            sym.__libc_csu_fini\n0x55fb45bf4814    1 9            sym._fini\n0x55fb45bf47a0    4 101          sym.__libc_csu_init\n0x55fb45bf471a    6 122          main\n0x55fb45bf45a0    3 23           sym._init\n0x55fb45bf45d0    1 6            sym.imp.puts\n0x55fb45bf45e0    1 6            sym.imp.__stack_chk_fail\n0x55fb45bf4000    2 25           map.home_kali_CTFs_tryhackme_Reverse_Engineering_crackme2.bin.r_x\n0x55fb45bf45f0    1 6            sym.imp.__isoc99_scanf\n[0x7f58df4df090]> pdf @main\n            ; DATA XREF from entry0 @ 0x55fb45bf462d\n\u250c 122: int main (int argc, char **argv, char **envp);\n\u2502           ; var int64_t var_ch @ rbp-0xc\n\u2502           ; var int64_t var_8h @ rbp-0x8\n\u2502           0x55fb45bf471a      55             push rbp\n\u2502           0x55fb45bf471b      4889e5         mov rbp, rsp\n\u2502           0x55fb45bf471e      4883ec10       sub rsp, 0x10\n\u2502           0x55fb45bf4722      64488b042528.  mov rax, qword fs:[0x28]\n\u2502           0x55fb45bf472b      488945f8       mov qword [var_8h], rax\n\u2502           0x55fb45bf472f      31c0           xor eax, eax\n\u2502           0x55fb45bf4731      488d3dec0000.  lea rdi, qword str.enter_your_password ; 0x55fb45bf4824 ; "enter your password"\n\u2502           0x55fb45bf4738      e893feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502           0x55fb45bf473d      488d45f4       lea rax, qword [var_ch]\n\u2502           0x55fb45bf4741      4889c6         mov rsi, rax\n\u2502           0x55fb45bf4744      488d3ded0000.  lea rdi, qword [0x55fb45bf4838] ; "%d"\n\u2502           0x55fb45bf474b      b800000000     mov eax, 0\n\u2502           0x55fb45bf4750      e89bfeffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)\n\u2502           0x55fb45bf4755      8b45f4         mov eax, dword [var_ch]\n\u2502           0x55fb45bf4758      3d7c130000     cmp eax, 0x137c\n\u2502       \u250c\u2500< 0x55fb45bf475d      750e           jne 0x55fb45bf476d\n\u2502       \u2502   0x55fb45bf475f      488d3dd50000.  lea rdi, qword str.password_is_valid ; 0x55fb45bf483b ; "password is valid"\n\u2502       \u2502   0x55fb45bf4766      e865feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502      \u250c\u2500\u2500< 0x55fb45bf476b      eb0c           jmp 0x55fb45bf4779\n\u2502      \u2502\u2514\u2500> 0x55fb45bf476d      488d3dd90000.  lea rdi, qword str.password_is_incorrect ; 0x55fb45bf484d ; "password is incorrect"\n\u2502      \u2502    0x55fb45bf4774      e857feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502      \u2502    ; CODE XREF from main @ 0x55fb45bf476b\n\u2502      \u2514\u2500\u2500> 0x55fb45bf4779      b800000000     mov eax, 0\n\u2502           0x55fb45bf477e      488b55f8       mov rdx, qword [var_8h]\n\u2502           0x55fb45bf4782      644833142528.  xor rdx, qword fs:[0x28]\n\u2502       \u250c\u2500< 0x55fb45bf478b      7405           je 0x55fb45bf4792\n\u2502       \u2502   0x55fb45bf478d      e84efeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)\n\u2502       \u2514\u2500> 0x55fb45bf4792      c9             leave\n\u2514           0x55fb45bf4793      c3             ret\n[0x7f58df4df090]>\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"kali@kali:~/CTFs/tryhackme/Reverse Engineering$ echo 'ibase=16; 137C' | bc\n4988\n")),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"What is the correct password?")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"kali@kali:~/CTFs/tryhackme/Reverse Engineering$ ./crackme2.bin\nenter your password\n4988\npassword is valid\n")),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"4988")),(0,t.kt)("h2",{id:"task-4-crackme3"},"Task 4 crackme3"),(0,t.kt)("p",null,"This crackme will be significantly more challenging - it involves learning how loops work, and how they are represented in assembly"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},'kali@kali:~/CTFs/tryhackme/Reverse Engineering$ r2 -d ./crackme3.bin\nProcess with PID 78868 started...\n= attach 78868 78868\nbin.baddr 0x5613e9b22000\nUsing 0x5613e9b22000\nasm.bits 64\nWarning: r_bin_file_hash: file exceeds bin.hashlimit\n[0x7f6163ed6090]> aaa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[x] Analyze function calls (aac)\n[x] Analyze len bytes of instructions for references (aar)\n[x] Check for objc references\n[x] Check for vtables\n[TOFIX: aaft can\'t run in debugger mode.ions (aaft)\n[x] Type matching analysis for all functions (aaft)\n[x] Propagate noreturn information\n[x] Use -AA or aaaa to perform additional experimental analysis.\n[0x7f6163ed6090]> afl\n0x5613e9b22610    1 42           entry0\n0x5613e9d22fe0    1 4124         reloc.__libc_start_main\n0x5613e9b22640    4 50   -> 40   sym.deregister_tm_clones\n0x5613e9b22680    4 66   -> 57   sym.register_tm_clones\n0x5613e9b226d0    5 58   -> 51   entry.fini0\n0x5613e9b22600    1 6            sym..plt.got\n0x5613e9b22710    1 10           entry.init0\n0x5613e9b22840    1 2            sym.__libc_csu_fini\n0x5613e9b22844    1 9            sym._fini\n0x5613e9b227d0    4 101          sym.__libc_csu_init\n0x5613e9b2271a    9 170          main\n0x5613e9b225a0    3 23           sym._init\n0x5613e9b225d0    1 6            sym.imp.puts\n0x5613e9b225e0    1 6            sym.imp.__stack_chk_fail\n0x5613e9b22000    2 25           map.home_kali_CTFs_tryhackme_Reverse_Engineering_crackme3.bin.r_x\n0x5613e9b225f0    1 6            sym.imp.__isoc99_scanf\n[0x7f6163ed6090]> pdf @main\n            ; DATA XREF from entry0 @ 0x5613e9b2262d\n\u250c 170: int main (int argc, char **argv, char **envp);\n\u2502           ; var int64_t var_28h @ rbp-0x28\n\u2502           ; var int64_t var_23h @ rbp-0x23\n\u2502           ; var int64_t var_21h @ rbp-0x21\n\u2502           ; var int64_t var_20h @ rbp-0x20\n\u2502           ; var int64_t var_8h @ rbp-0x8\n\u2502           0x5613e9b2271a      55             push rbp\n\u2502           0x5613e9b2271b      4889e5         mov rbp, rsp\n\u2502           0x5613e9b2271e      4883ec30       sub rsp, 0x30\n\u2502           0x5613e9b22722      64488b042528.  mov rax, qword fs:[0x28]\n\u2502           0x5613e9b2272b      488945f8       mov qword [var_8h], rax\n\u2502           0x5613e9b2272f      31c0           xor eax, eax\n\u2502           0x5613e9b22731      66c745dd617a   mov word [var_23h], 0x7a61 ; \'az\'\n\u2502           0x5613e9b22737      c645df74       mov byte [var_21h], 0x74 ; \'t\' ; 116\n\u2502           0x5613e9b2273b      488d3d120100.  lea rdi, qword str.enter_your_password ; 0x5613e9b22854 ; "enter your password"\n\u2502           0x5613e9b22742      e889feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502           0x5613e9b22747      488d45e0       lea rax, qword [var_20h]\n\u2502           0x5613e9b2274b      4889c6         mov rsi, rax\n\u2502           0x5613e9b2274e      488d3d130100.  lea rdi, qword [0x5613e9b22868] ; "%s"\n\u2502           0x5613e9b22755      b800000000     mov eax, 0\n\u2502           0x5613e9b2275a      e891feffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)\n\u2502           0x5613e9b2275f      c745d8000000.  mov dword [var_28h], 0\n\u2502       \u250c\u2500< 0x5613e9b22766      eb2f           jmp 0x5613e9b22797\n\u2502      \u250c\u2500\u2500> 0x5613e9b22768      8b45d8         mov eax, dword [var_28h]\n\u2502      \u254e\u2502   0x5613e9b2276b      4898           cdqe\n\u2502      \u254e\u2502   0x5613e9b2276d      0fb65405e0     movzx edx, byte [rbp + rax - 0x20]\n\u2502      \u254e\u2502   0x5613e9b22772      8b45d8         mov eax, dword [var_28h]\n\u2502      \u254e\u2502   0x5613e9b22775      4898           cdqe\n\u2502      \u254e\u2502   0x5613e9b22777      0fb64405dd     movzx eax, byte [rbp + rax - 0x23]\n\u2502      \u254e\u2502   0x5613e9b2277c      38c2           cmp dl, al\n\u2502     \u250c\u2500\u2500\u2500< 0x5613e9b2277e      7413           je 0x5613e9b22793\n\u2502     \u2502\u254e\u2502   0x5613e9b22780      488d3de40000.  lea rdi, qword str.password_is_incorrect ; 0x5613e9b2286b ; "password is incorrect"\n\u2502     \u2502\u254e\u2502   0x5613e9b22787      e844feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502     \u2502\u254e\u2502   0x5613e9b2278c      b800000000     mov eax, 0\n\u2502    \u250c\u2500\u2500\u2500\u2500< 0x5613e9b22791      eb1b           jmp 0x5613e9b227ae\n\u2502    \u2502\u2514\u2500\u2500\u2500> 0x5613e9b22793      8345d801       add dword [var_28h], 1\n\u2502    \u2502 \u254e\u2502   ; CODE XREF from main @ 0x5613e9b22766\n\u2502    \u2502 \u254e\u2514\u2500> 0x5613e9b22797      837dd802       cmp dword [var_28h], 2\n\u2502    \u2502 \u2514\u2500\u2500< 0x5613e9b2279b      7ecb           jle 0x5613e9b22768\n\u2502    \u2502      0x5613e9b2279d      488d3ddd0000.  lea rdi, qword str.password_is_correct ; 0x5613e9b22881 ; "password is correct"\n\u2502    \u2502      0x5613e9b227a4      e827feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502    \u2502      0x5613e9b227a9      b800000000     mov eax, 0\n\u2502    \u2502      ; CODE XREF from main @ 0x5613e9b22791\n\u2502    \u2514\u2500\u2500\u2500\u2500> 0x5613e9b227ae      488b4df8       mov rcx, qword [var_8h]\n\u2502           0x5613e9b227b2      6448330c2528.  xor rcx, qword fs:[0x28]\n\u2502       \u250c\u2500< 0x5613e9b227bb      7405           je 0x5613e9b227c2\n\u2502       \u2502   0x5613e9b227bd      e81efeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)\n\u2502       \u2514\u2500> 0x5613e9b227c2      c9             leave\n\u2514           0x5613e9b227c3      c3             ret\n[0x7f6163ed6090]>\n[0x5613e9b2275f]> ds\n[0x5613e9b22766]> pdf @main\n            ; DATA XREF from entry0 @ 0x5613e9b2262d\n\u250c 170: int main (int argc, char **argv, char **envp);\n\u2502           ; var int64_t var_28h @ rbp-0x28\n\u2502           ; var int64_t var_23h @ rbp-0x23\n\u2502           ; var int64_t var_21h @ rbp-0x21\n\u2502           ; var int64_t var_20h @ rbp-0x20\n\u2502           ; var int64_t var_8h @ rbp-0x8\n\u2502           0x5613e9b2271a      55             push rbp\n\u2502           0x5613e9b2271b      4889e5         mov rbp, rsp\n\u2502           0x5613e9b2271e      4883ec30       sub rsp, 0x30\n\u2502           0x5613e9b22722      64488b042528.  mov rax, qword fs:[0x28]\n\u2502           0x5613e9b2272b      488945f8       mov qword [var_8h], rax\n\u2502           0x5613e9b2272f      31c0           xor eax, eax\n\u2502           0x5613e9b22731      66c745dd617a   mov word [var_23h], 0x7a61 ; \'az\'\n\u2502           0x5613e9b22737      c645df74       mov byte [var_21h], 0x74 ; \'t\' ; 116\n\u2502           0x5613e9b2273b      488d3d120100.  lea rdi, qword str.enter_your_password ; 0x5613e9b22854 ; "enter your password"\n\u2502           0x5613e9b22742      e889feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502           0x5613e9b22747      488d45e0       lea rax, qword [var_20h]\n\u2502           0x5613e9b2274b      4889c6         mov rsi, rax\n\u2502           0x5613e9b2274e      488d3d130100.  lea rdi, qword [0x5613e9b22868] ; "%s"\n\u2502           0x5613e9b22755      b800000000     mov eax, 0\n\u2502           0x5613e9b2275a      e891feffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)\n\u2502           0x5613e9b2275f b    c745d8000000.  mov dword [var_28h], 0\n\u2502           ;-- rip:\n\u2502       \u250c\u2500< 0x5613e9b22766      eb2f           jmp 0x5613e9b22797\n\u2502      \u250c\u2500\u2500> 0x5613e9b22768      8b45d8         mov eax, dword [var_28h]\n\u2502      \u254e\u2502   0x5613e9b2276b      4898           cdqe\n\u2502      \u254e\u2502   0x5613e9b2276d      0fb65405e0     movzx edx, byte [rbp + rax - 0x20]\n\u2502      \u254e\u2502   0x5613e9b22772      8b45d8         mov eax, dword [var_28h]\n\u2502      \u254e\u2502   0x5613e9b22775      4898           cdqe\n\u2502      \u254e\u2502   0x5613e9b22777      0fb64405dd     movzx eax, byte [rbp + rax - 0x23]\n\u2502      \u254e\u2502   0x5613e9b2277c      38c2           cmp dl, al\n\u2502     \u250c\u2500\u2500\u2500< 0x5613e9b2277e      7413           je 0x5613e9b22793\n\u2502     \u2502\u254e\u2502   0x5613e9b22780      488d3de40000.  lea rdi, qword str.password_is_incorrect ; 0x5613e9b2286b ; "password is incorrect"\n\u2502     \u2502\u254e\u2502   0x5613e9b22787      e844feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502     \u2502\u254e\u2502   0x5613e9b2278c      b800000000     mov eax, 0\n\u2502    \u250c\u2500\u2500\u2500\u2500< 0x5613e9b22791      eb1b           jmp 0x5613e9b227ae\n\u2502    \u2502\u2514\u2500\u2500\u2500> 0x5613e9b22793      8345d801       add dword [var_28h], 1\n\u2502    \u2502 \u254e\u2502   ; CODE XREF from main @ 0x5613e9b22766\n\u2502    \u2502 \u254e\u2514\u2500> 0x5613e9b22797      837dd802       cmp dword [var_28h], 2\n\u2502    \u2502 \u2514\u2500\u2500< 0x5613e9b2279b b    7ecb           jle 0x5613e9b22768\n\u2502    \u2502      0x5613e9b2279d      488d3ddd0000.  lea rdi, qword str.password_is_correct ; 0x5613e9b22881 ; "password is correct"\n\u2502    \u2502      0x5613e9b227a4      e827feffff     call sym.imp.puts       ; int puts(const char *s)\n\u2502    \u2502      0x5613e9b227a9      b800000000     mov eax, 0\n\u2502    \u2502      ; CODE XREF from main @ 0x5613e9b22791\n\u2502    \u2514\u2500\u2500\u2500\u2500> 0x5613e9b227ae      488b4df8       mov rcx, qword [var_8h]\n\u2502           0x5613e9b227b2      6448330c2528.  xor rcx, qword fs:[0x28]\n\u2502       \u250c\u2500< 0x5613e9b227bb      7405           je 0x5613e9b227c2\n\u2502       \u2502   0x5613e9b227bd      e81efeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)\n\u2502       \u2514\u2500> 0x5613e9b227c2      c9             leave\n\u2514           0x5613e9b227c3      c3             ret\n[0x5613e9b22766]> px @ rbp-0x28\n- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF\n0x7ffc957a00a8  0000 0000 0061 7a74 3132 3300 1356 0000  .....azt123..V..\n0x7ffc957a00b8  1026 b2e9 1356 0000 c001 7a95 fc7f 0000  .&...V....z.....\n0x7ffc957a00c8  00ab 71c8 1002 107d d027 b2e9 1356 0000  ..q....}.\'...V..\n0x7ffc957a00d8  cacc d163 617f 0000 c801 7a95 fc7f 0000  ...ca.....z.....\n0x7ffc957a00e8  0000 0000 0100 0000 1a27 b2e9 1356 0000  .........\'...V..\n0x7ffc957a00f8  d9c7 d163 617f 0000 0000 0000 0000 0000  ...ca...........\n0x7ffc957a0108  4133 bc38 9e6d 2fdc 1026 b2e9 1356 0000  A3.8.m/..&...V..\n0x7ffc957a0118  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x7ffc957a0128  0000 0000 0000 0000 4133 dc76 0e94 f18f  ........A3.v....\n0x7ffc957a0138  4133 1aee 5979 ca8e 0000 0000 0000 0000  A3..Yy..........\n0x7ffc957a0148  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x7ffc957a0158  0100 0000 0000 0000 c801 7a95 fc7f 0000  ..........z.....\n0x7ffc957a0168  d801 7a95 fc7f 0000 8011 f063 617f 0000  ..z........ca...\n0x7ffc957a0178  0000 0000 0000 0000 0000 0000 0000 0000  ................\n0x7ffc957a0188  1026 b2e9 1356 0000 c001 7a95 fc7f 0000  .&...V....z.....\n0x7ffc957a0198  0000 0000 0000 0000 0000 0000 0000 0000  ................\n')),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"What are the first 3 letters of the correct password?")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"kali@kali:~/CTFs/tryhackme/Reverse Engineering$ ./crackme3.bin\nenter your password\nazt\npassword is correct\n")),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"azt")))}d.isMDXComponent=!0}}]);