"use strict";(self.webpackChunkcyfun_me=self.webpackChunkcyfun_me||[]).push([[8099],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20141:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={},o="Intro to x86-64",l={unversionedId:"Tryhackme/Intro to x86-64/Intro to x86 and 64",id:"Tryhackme/Intro to x86-64/Intro to x86 and 64",title:"Intro to x86-64",description:"This room teaches the basics of x86-64 assembly language",source:"@site/writeups/Tryhackme/Intro to x86-64/Intro to x86 and 64.md",sourceDirName:"Tryhackme/Intro to x86-64",slug:"/Tryhackme/Intro to x86-64/Intro to x86 and 64",permalink:"/writeups/Tryhackme/Intro to x86-64/Intro to x86 and 64",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Intro to Python",permalink:"/writeups/Tryhackme/Intro to Python/"},next:{title:"Introduction to Django",permalink:"/writeups/Tryhackme/Introduction to Django/"}},s={},p=[{value:"\ud83d\udca2 We will cover  the topics",id:"-we-will-cover--the-topics",level:2},{value:"Task 1 Description and Objectives",id:"task-1-description-and-objectives",level:2},{value:"Task 2 Introduction",id:"task-2-introduction",level:2},{value:"Task 3 If Statements",id:"task-3-if-statements",level:2},{value:"Task 4 If Statements Continued",id:"task-4-if-statements-continued",level:2},{value:"Task 5 Loops",id:"task-5-loops",level:2},{value:"Task 6 crackme1",id:"task-6-crackme1",level:2},{value:"Task 7 crackme2",id:"task-7-crackme2",level:2}],u={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"intro-to-x86-64"},"Intro to x86-64"),(0,r.kt)("p",null,"This room teaches the basics of x86-64 assembly language"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://tryhackme.com/room/introtox8664"},"Intro to x86-64")),(0,r.kt)("h2",{id:"-we-will-cover--the-topics"},"\ud83d\udca2 We will cover  the topics"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Reverse Engineering"),(0,r.kt)("li",{parentName:"ul"},"Radar 2 Fundamentals")),(0,r.kt)("h2",{id:"task-1-description-and-objectives"},"Task 1 Description and Objectives"),(0,r.kt)("p",null,"This room will look at the basic primitives of Intel's x86-64 assembly language, and will use these primitives to understand the construction of basic programs using loops, functions and procedures. The tasks attached to this room will use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/radare/radare2"},"r2 reverse engineering")," framework, which will come installed in the machine attached to this room. The username of the machine attached to the next task is ",(0,r.kt)("strong",{parentName:"p"},"tryhackme")," and the password is ",(0,r.kt)("strong",{parentName:"p"},"reismyfavl33t"),". To access the machine, SSH into it on port 22."),(0,r.kt)("p",null,"Here are a few things to note before beginning the room:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"this room will use the AT&T syntax. In general, people either use the AT&T syntax or the Intel Syntax(differences are highlighted here)."),(0,r.kt)("li",{parentName:"ul"},"This room aims to be a gentle introduction to radare2. While they are not shown here, radare has a lot of powerful features and tools which can be found ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/radare/radare2/blob/master/doc/intro.md"},"here"),", ",(0,r.kt)("a",{parentName:"li",href:"https://gist.github.com/williballenthin/6857590dab3e2a6559d7"},"here")," and ",(0,r.kt)("a",{parentName:"li",href:"https://www.radare.org/get/THC2018.pdf"},"here")),(0,r.kt)("li",{parentName:"ul"},"As soon as your start r2, remember to enter e asm.syntax=att to ensure that you are using the AT&T syntax."),(0,r.kt)("li",{parentName:"ul"},"The addresses shown on the images in the tasks below may be different from the addresses you view when you disassemble the files.")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Read the above.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"No answer needed")),(0,r.kt)("h2",{id:"task-2-introduction"},"Task 2 Introduction"),(0,r.kt)("p",null,"Computers execute machine code, which is encoded as bytes, to carry out tasks on a computer. Since different computers have different processors, the machine code executed on these computers is specific to the processor. In this case, we\u2019ll be looking at the Intel x86-64 instruction set architecture which is most commonly found today. Machine code is usually represented by a more readable form of the code called assembly code. This machine is code is usually produced by a compiler, which takes the source code of a file, and after going through some intermediate stages, produces machine code that can be executed by a computer. Without going into too much detail, Intel first started out by building 16-bit instruction set, followed by 32 bit, after which they finally created 64 bit. All these instruction sets have been created for backward compatibility, so code compiled for 32 bit architecture will run on 64 bit machines. As mentioned earlier, before an executable file is produced, the source code is first compiled into assembly(.s files), after which the assembler converts it into an object program(.o files), and operations with a linker finally make it an executable. "),(0,r.kt)("p",null,"The best way to actually start explaining assembly is by diving in. We\u2019ll be using radare2 to do this - radare2 is a framework for reverse engineering and analysing binaries. It can be used to disassemble binaries(translate machine code to assembly, which is actually readable) and debug said binaries(by allowing a user to step through the execution and view the state of the program). "),(0,r.kt)("p",null,"The first step is to execute the program intro by running ",(0,r.kt)("inlineCode",{parentName:"p"},"./intro")),(0,r.kt)("p",null,"Which then just shows the following output"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh5.googleusercontent.com/JjT_G7sF5ScGMJWTisYH3N49djt64Dx2_6CkOtXBSezoheO0uo7wlu0FQBLBLTyjA_PsRDHrRYTYrvqtA0NVFG0Kt2EGosxx7QvBf32cEjSMSYEOh85uRFJFKy2AxLhsovfUTT9O",alt:null})),(0,r.kt)("p",null,"From the execution, it can be seen that the program is creating two variables and switching their values. Time to see what it\u2019s actually doing under the hood!"),(0,r.kt)("p",null,"Go to the introduction folder on the virtual machine and run the command: ",(0,r.kt)("inlineCode",{parentName:"p"},"r2 -d intro")),(0,r.kt)("p",null,"This will open the binary in debugging mode. Once the binary is open, one of the first things to do is ask r2 to analyze the program, and this can be done by typing in: ",(0,r.kt)("inlineCode",{parentName:"p"},"aa")),(0,r.kt)("p",null,"Which is the most common analysis command. It analyses all symbols and entry points in the executable."),(0,r.kt)("p",null,"The run ",(0,r.kt)("inlineCode",{parentName:"p"},"e asm.syntax=att")," to set the disassembly syntax to AT&T."),(0,r.kt)("p",null,"The analysis in this case involves extracting function names, flow control information and much more! r2 instructions are usually based on a single character, so it is easy to get more information about the commands. For general help, run: ",(0,r.kt)("inlineCode",{parentName:"p"},"?")),(0,r.kt)("p",null,"For more specific information, for example, about analysis, run ",(0,r.kt)("inlineCode",{parentName:"p"},"a?")),(0,r.kt)("p",null,"Once the analysis is complete, you would want to know where to start analysing from - most programs have an entry point defined as main. To find a list of the functions run: ",(0,r.kt)("inlineCode",{parentName:"p"},"afl")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh4.googleusercontent.com/OMdwgZHBcZxoBjRON-zmPmdlfeaCcZUstR0S5qev7mofmxTEGwVzkZAenUYlKXEy94wBWA8XoSsWQnXbwAroPPj2gq1rrrytoavs-Vc97PwK9eblUtGx-DBj3EMHS7xXN5Jn2_9f",alt:null})),(0,r.kt)("p",null,"As seen here, there actually is a function at main. Let\u2019s examine the assembly code at main by running the command ",(0,r.kt)("inlineCode",{parentName:"p"},"pdf @main")),(0,r.kt)("p",null,"Where pdf means print disassembly function. Doing so will give us the following view"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh4.googleusercontent.com/HometWAQT4JO7lJN5-tipL_tiBL8T270njUm4bTTdIIXIXOm3oEb41YhuUcq1dl0oK5b_y5QfqbzZJlDsPQKQ-G7LMVqPADbpz1uvD6TfCM7UONbEAmAVn_bae7W2Rpj2dfZDJDV",alt:null})),(0,r.kt)("p",null,"As we can see from above, the values on the complete left column are memory addresses of the instructions, and these are usually stored in a structure called the stack(which we will talk about later). The middle column contains the instructions encoded in bytes(what is usually the machine code), and the last column actually contains the human readable instructions. "),(0,r.kt)("p",null,"The core of assembly language involves using registers to do the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Transfer data between memory and register, and vice versa"),(0,r.kt)("li",{parentName:"ul"},"Perform arithmetic operations on registers and data"),(0,r.kt)("li",{parentName:"ul"},"Transfer control to other parts of the program")),(0,r.kt)("p",null,"Since the architecture is x86-64, the registers are 64 bit and Intel has a list of 16 registers:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"64 bit"),(0,r.kt)("th",{parentName:"tr",align:null},"32 bit"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rax"),(0,r.kt)("td",{parentName:"tr",align:null},"%eax")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rbx"),(0,r.kt)("td",{parentName:"tr",align:null},"%ebx")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rcx"),(0,r.kt)("td",{parentName:"tr",align:null},"%ecx")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rdx"),(0,r.kt)("td",{parentName:"tr",align:null},"%edx")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rsi"),(0,r.kt)("td",{parentName:"tr",align:null},"%esi")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rdi"),(0,r.kt)("td",{parentName:"tr",align:null},"%edi")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rsp"),(0,r.kt)("td",{parentName:"tr",align:null},"%esp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%rbp"),(0,r.kt)("td",{parentName:"tr",align:null},"%ebp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r8"),(0,r.kt)("td",{parentName:"tr",align:null},"%r8d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r9"),(0,r.kt)("td",{parentName:"tr",align:null},"%r9d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r10"),(0,r.kt)("td",{parentName:"tr",align:null},"%r10d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r11"),(0,r.kt)("td",{parentName:"tr",align:null},"%r11d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r12"),(0,r.kt)("td",{parentName:"tr",align:null},"%r12d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r13"),(0,r.kt)("td",{parentName:"tr",align:null},"%r13d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r14"),(0,r.kt)("td",{parentName:"tr",align:null},"%r14d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"%r15"),(0,r.kt)("td",{parentName:"tr",align:null},"%r15d")))),(0,r.kt)("p",null,"Even though the registers are 64 bit, meaning they can hold up to 64 bits of data, other parts of the registers can also be referenced. In this case, registers can also be referenced as 32 bit values as shown. What isn\u2019t shown is that registers can be referenced as 16 bit and 8 bit(higher 4 bit and lower 4 bit)."),(0,r.kt)("p",null,"The first 6 registers are known as general purpose registers. The %rsp is the stack pointer and it points to the top of the stack which contains the most recent memory address. The stack is a data structure that manages memory for programs. %rbp is a frame pointer and points to the frame of the function currently being executed - every function is executed in a new frame. To move data using registers, the following instruction is used: ",(0,r.kt)("inlineCode",{parentName:"p"},"movq source, destination")),(0,r.kt)("p",null,"This involves:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Transferring constants(which are prefixed using the $ operator) e.g. movq $3 rax would move the constant 3 to the register"),(0,r.kt)("li",{parentName:"ul"},"Transferring values from a register e.g. movq %rax %rbx which involves moving value from rax to rbx"),(0,r.kt)("li",{parentName:"ul"},"Transferring values from memory which is shown by putting registers inside brackets e.g. movq %rax (%rbx) which means move value stored in %rax to memory location represented by %rbx.")),(0,r.kt)("p",null,"The last letter of the mov instruction represents the size of the data:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Intel Data Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Suffix"),(0,r.kt)("th",{parentName:"tr",align:null},"Size(bytes)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Byte"),(0,r.kt)("td",{parentName:"tr",align:null},"b"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Word"),(0,r.kt)("td",{parentName:"tr",align:null},"w"),(0,r.kt)("td",{parentName:"tr",align:null},"2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Double Word"),(0,r.kt)("td",{parentName:"tr",align:null},"l"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Quad Word"),(0,r.kt)("td",{parentName:"tr",align:null},"q"),(0,r.kt)("td",{parentName:"tr",align:null},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Single Precision"),(0,r.kt)("td",{parentName:"tr",align:null},"s"),(0,r.kt)("td",{parentName:"tr",align:null},"4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Double Precision"),(0,r.kt)("td",{parentName:"tr",align:null},"l"),(0,r.kt)("td",{parentName:"tr",align:null},"8")))),(0,r.kt)("p",null,"When dealing with memory manipulation using registers, there are other cases to be considered:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"(Rb, Ri) = MemoryLocation","[Rb + Ri]"),(0,r.kt)("li",{parentName:"ul"},"D(Rb, Ri) = MemoryLocation","[Rb + Ri + D]"),(0,r.kt)("li",{parentName:"ul"},"(Rb, Ri, S) = MemoryLocation(Rb + S * Ri]"),(0,r.kt)("li",{parentName:"ul"},"D(Rb, Ri, S) = MemoryLocation","[Rb + S * Ri + D]")),(0,r.kt)("p",null,"Some other important instructions are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"leaq source, destination")," : this instruction sets destination to the address denoted by the expression in source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addq source, destination")," : destination = destination + source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subq source, destination")," : destination = destination - source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"imulq source, destination")," : destination = destination * source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"salq source, destination")," : destination = destination << source where << is the left bit shifting operator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sarq source, destination")," : destination = destination >> source where >> is the right bit shifting operator"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"xorq source, destination")," : destination = destination XOR source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"andq source, destination")," : destination = destination & source"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"orq source, destination")," : destination = destination | source")),(0,r.kt)("p",null,"Before understanding how programs work, it is important to understand registers, memory manipulation and some basic instructions. The next sections will have more hands on use of radare2."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Read and experiment with the above.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-r2"},"tryhackme@ip-10-10-157-0:~$ cd introduction/\ntryhackme@ip-10-10-157-0:~/introduction$ ls\nintro  intro.c\ntryhackme@ip-10-10-157-0:~/introduction$ ./intro \nvalue for a is 1 and b is 2\nvalue of a is 2 and b is 1\ntryhackme@ip-10-10-157-0:~/introduction$ r2 -d intro\nProcess with PID 1403 started...\n= attach 1403 1403\nbin.baddr 0x55a23ea29000\nUsing 0x55a23ea29000\nasm.bits 64\n -- radare2 0.9.7 is so old, my grandfarther was using it with his enigma in WWII\n[0x7feb629b2090]> aa\n[x] Analyze all flags starting with sym. and entry0 (aa)\n[0x7feb629b2090]> e asm.syntax=att\n[0x7feb629b2090]> ?\nUsage: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...   \nAppend '?' to any char command to get detailed help\nPrefix with number to repeat command N times (f.ex: 3x)\n| %var=value              alias for 'env' command\n| *[?] off[=[0x]value]    pointer read/write data/values (see ?v, wx, wv)\n| (macro arg0 arg1)       manage scripting macros\n| .[?] [-|(m)|f|!sh|cmd]  Define macro or load r2, cparse or rlang file\n| _[?]                    Print last output\n| =[?] [cmd]              send/listen for remote commands (rap://, raps://, udp://, http://, <fd>)\n| <[...]                  push escaped string into the RCons.readChar buffer\n| /[?]                    search for bytes, regexps, patterns, ..\n| ![?] [cmd]              run given command as in system(3)\n| #[?] !lang [..]         Hashbang to run an rlang script\n| a[?]                    analysis commands\n| b[?]                    display or change the block size\n| c[?] [arg]              compare block with given data\n| C[?]                    code metadata (comments, format, hints, ..)\n| d[?]                    debugger commands\n| e[?] [a[=b]]            list/get/set config evaluable vars\n| f[?] [name][sz][at]     add flag at current address\n| g[?] [arg]              generate shellcodes with r_egg\n| i[?] [file]             get info about opened file from r_bin\n| k[?] [sdb-query]        run sdb-query. see k? for help, 'k *', 'k **' ...\n| l [filepattern]         list files and directories\n| L[?] [-] [plugin]       list, unload load r2 plugins\n| m[?]                    mountpoints commands\n| o[?] [file] ([offset])  open file at optional address\n| p[?] [len]              print current block with format and length\n| P[?]                    project management utilities\n| q[?] [ret]              quit program with a return value\n| r[?] [len]              resize file\n| s[?] [addr]             seek to address (also for '0x', '0x1' == 's 0x1')\n| t[?]                    types, noreturn, signatures, C parser and more\n| T[?] [-] [num|msg]      Text log utility (used to chat, sync, log, ...)\n| u[?]                    uname/undo seek/write\n| v                       visual mode (v! = panels, vv = fcnview, vV = fcngraph, vVV = callgraph)\n| w[?] [str]              multiple write operations\n| x[?] [len]              alias for 'px' (print hexadecimal)\n| y[?] [len] [[[@]addr    Yank/paste bytes from/to memory\n| z[?]                    zignatures management\n| ?[??][expr]             Help or evaluate math expression\n| ?$?                     show available '$' variables and aliases\n| ?@?                     misc help for '@' (seek), '~' (grep) (see ~??)\n| ?>?                     output redirection\n[0x7feb629b2090]> a?\nUsage: a  [abdefFghoprxstc] [...]\n| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)\n| a8 [hexpairs]      analyze bytes\n| ab[b] [addr]       analyze block at given address\n| abb [len]          analyze N basic blocks in [len] (section.size by default)\n| ac[?]              manage classes\n| aC[?]              analyze function call\n| aCe[?]             same as aC, but uses esil with abte to emulate the function\n| ad[?]              analyze data trampoline (wip)\n| ad [from] [to]     analyze data pointers to (from-to)\n| ae[?] [expr]       analyze opcode eval expression (see ao)\n| af[?]              analyze Functions\n| aF                 same as above, but using anal.depth=1\n| ag[?] [options]    draw graphs in various formats\n| ah[?]              analysis hints (force opcode size, ...)\n| ai [addr]          address information (show perms, stack, heap, ...)\n| aL                 list all asm/anal plugins (e asm.arch=?)\n| an [name] [@addr]  show/rename/create whatever flag/function is used at addr\n| ao[?] [len]        analyze Opcodes (or emulate it)\n| aO[?] [len]        Analyze N instructions in M bytes\n| ap                 find prelude for current offset\n| ar[?]              like 'dr' but for the esil vm. (registers)\n| as[?] [num]        analyze syscall using dbg.reg\n| av[?] [.]          show vtables\n| ax[?]              manage refs/xrefs (see also afx?)\n[0x7feb629b2090]> afl\n0x55a23ea29560    1 42           entry0\n0x55a23ec29fe0    1 4124         reloc.__libc_start_main\n0x55a23ea29590    4 50   -> 40   sym.deregister_tm_clones\n0x55a23ea295d0    4 66   -> 57   sym.register_tm_clones\n0x55a23ea29620    5 58   -> 51   entry.fini0\n0x55a23ea29550    1 6            sym..plt.got\n0x55a23ea29660    1 10           entry.init0\n0x55a23ea29730    1 2            sym.__libc_csu_fini\n0x55a23ea29734    1 9            sym._fini\n0x55a23ea296c0    4 101          sym.__libc_csu_init\n0x55a23ea2966a    1 78           main\n0x55a23ea29540    1 6            sym.imp.__printf_chk\n0x55a23ea29510    3 23           sym._init\n0x55a23ea29000    3 97   -> 123  map.home_tryhackme_introduction_intro.r_x\n[0x7feb629b2090]> pdf @main\n/ (fcn) main 78\n|   int main (int argc, char **argv, char **envp);\n|           ; DATA XREF from entry0 (0x55a23ea2957d)\n|           0x55a23ea2966a      4883ec08       subq $8, %rsp\n|           0x55a23ea2966e      b902000000     movl $2, %ecx\n|           0x55a23ea29673      ba01000000     movl $1, %edx\n|           0x55a23ea29678      488d35c90000.  leaq str.value_for_a_is__d_and_b_is__d, %rsi ; 0x55a23ea29748 ; \"value for a is %d and b is %d\\n\"\n|           0x55a23ea2967f      bf01000000     movl $1, %edi\n|           0x55a23ea29684      b800000000     movl $0, %eax\n|           0x55a23ea29689      e8b2feffff     callq sym.imp.__printf_chk\n|           0x55a23ea2968e      b901000000     movl $1, %ecx\n|           0x55a23ea29693      ba02000000     movl $2, %edx\n|           0x55a23ea29698      488d35c90000.  leaq str.value_of_a_is__d_and_b_is__d, %rsi ; 0x55a23ea29768 ; \"value of a is %d and b is %d\\n\"\n|           0x55a23ea2969f      bf01000000     movl $1, %edi\n|           0x55a23ea296a4      b800000000     movl $0, %eax\n|           0x55a23ea296a9      e892feffff     callq sym.imp.__printf_chk\n|           0x55a23ea296ae      b800000000     movl $0, %eax\n|           0x55a23ea296b3      4883c408       addq $8, %rsp\n\\           0x55a23ea296b7      c3             retq\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"No answer needed")),(0,r.kt)("h2",{id:"task-3-if-statements"},"Task 3 If Statements"),(0,r.kt)("p",null,"The general format of an if statement is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"if(condition){\n    do-stuff-here\n} else if(condition) //this is an optional condition {\n    do-stuff-here\n} else {\n    do-stuff-here\n}\n")),(0,r.kt)("p",null,"If statements use 3 important instructions in assembly:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"cmpq source2, source1: it is like computing a-b without setting destination"),(0,r.kt)("li",{parentName:"ul"},"testq source2, source1: it is like computing a&b without setting destination")),(0,r.kt)("p",null,"Jump instructions are used to transfer control to different instructions, and there are different types of jumps:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Jump Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jmp"),(0,r.kt)("td",{parentName:"tr",align:null},"Unconditional")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"je"),(0,r.kt)("td",{parentName:"tr",align:null},"Equal/Zero")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jne"),(0,r.kt)("td",{parentName:"tr",align:null},"Not Equal/Not Zero")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"js"),(0,r.kt)("td",{parentName:"tr",align:null},"Negative")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jns"),(0,r.kt)("td",{parentName:"tr",align:null},"Nonnegative")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jg"),(0,r.kt)("td",{parentName:"tr",align:null},"Greater")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jge"),(0,r.kt)("td",{parentName:"tr",align:null},"Greater or Equal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jl"),(0,r.kt)("td",{parentName:"tr",align:null},"Less")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jle"),(0,r.kt)("td",{parentName:"tr",align:null},"Less or Equal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ja"),(0,r.kt)("td",{parentName:"tr",align:null},"Above(unsigned)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jb"),(0,r.kt)("td",{parentName:"tr",align:null},"Below(unsigned)")))),(0,r.kt)("p",null,"The last 2 values of the table refer to unsigned integers. Unsigned integers cannot be negative while signed integers represent both positive and negative values. SInce the computer needs to differentiate between them, it uses different methods to interpret these values. For signed integers, it uses something called the two\u2019s complement representation and for unsigned integers it uses normal binary calculations."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Read and experiment with the above.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"No answer needed")),(0,r.kt)("h2",{id:"task-4-if-statements-continued"},"Task 4 If Statements Continued"),(0,r.kt)("p",null,"Go to the if-statement folder and Start r2 with ",(0,r.kt)("inlineCode",{parentName:"p"},"r2 -d if1")),(0,r.kt)("p",null,"And run the following commands:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"aaa")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"afl")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pdf @main"))),(0,r.kt)("p",null,"This analyses the program, lists the functions and disassembles the main function."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh4.googleusercontent.com/SWXZLnHK52fyB4BtLsq4b-YC0uucB8P219xVEc4ilFrGiFf0usbMzzzuzx1m3KEF94__4Ox9sCP256VVHkWUOx3DUhVcS9a03eG3FONST3C2gCD9Kt8pCmmM2r-6rl1TFOeMkLGk",alt:null})),(0,r.kt)("p",null,"We\u2019ll then start by setting a break point on the ",(0,r.kt)("inlineCode",{parentName:"p"},"jge")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"jmp")," instruction by using the command:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"db 0x55ae52836612")," (which is the hex address of the jge instruction) "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"db 0x55ae52836618")," (which is the hex address of the jmp instruction)")),(0,r.kt)("p",null,"We\u2019ve added breakpoints to stop the execution of the program at those points so we can see the state of the program. Doing so will show the following:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh6.googleusercontent.com/9aI231aVGvJr4mWImailUL5Z0zjQ-IuOnHgKxybK2jX-bAXp2uHlqggTTdLtwyANTyq_Q1anXDgnUl1Goxe9WhFGi6n5QcKzef9vAfnRdfycB5Q2icI8ZOGrafnmP2PomCjOsOCk",alt:null})),(0,r.kt)("p",null,"We now run ",(0,r.kt)("inlineCode",{parentName:"p"},"dc")," to start execution of the program and the program will start execution and stop at the break point. Let\u2019s examine what has happened before hitting the breakpoint:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The first 2 lines are about pushing the frame pointer onto the stack and saving it(this is about how functions are called, and will be examined later)"),(0,r.kt)("li",{parentName:"ul"},"The next 3 lines are about assigning values 3 and 4 to the local arguments/variables var_8h and var_4h. It then stores the value in var_8h in the %eax register."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"cmpl")," instruction compares the value of eax with that of the var_8h argument")),(0,r.kt)("p",null,"To view the value of the registers, type in: ",(0,r.kt)("inlineCode",{parentName:"p"},"dr")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh5.googleusercontent.com/dIlnkagpBvm0pX7AFwYDStfJp4UqA48PUmOv2qf_BcZwVu7OsgYoKInNZ16iv_k4xbC3XqUxB8IbVbscKtnQ2TmdhHRIpWuTbvezdjd6ZcHfcSv3H1heeD05-K4Se9e_MCi9Qdw1",alt:null})),(0,r.kt)("p",null,"We can see that the value of rax, which is the 64 bit version of eax contains 3. We saw that the jge instruction is jumping based on whether value of eax is greater than var_4h. To see what\u2019s in var_4h, we can see that at top of the main function, it tells us the position of var_4h. Run the command: ",(0,r.kt)("inlineCode",{parentName:"p"},"px @rbp-0x4")),(0,r.kt)("p",null,"And that shows the value of 4. "),(0,r.kt)("p",null,"We know that eax contains 3, and 3 is not greater than 4, so the jump will not execute. Instead it will move to the next instruction. To check this, run the ",(0,r.kt)("inlineCode",{parentName:"p"},"ds")," command which seeks/moves onto the next instruction."),(0,r.kt)("p",null,"The rip(which is the current instruction pointer) shows that it moves onto the next instruction - which shows we are correct. The current instruction then adds 5 to var_8h which is a local argument. To see that this actually happens, first check the value of var_8h, run ",(0,r.kt)("inlineCode",{parentName:"p"},"ds")," and check the value again. This will show it increments by 5."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh5.googleusercontent.com/epOtH0brvnOKjW9GLbv8ZgcSUsREsGrMJrcMh0HJkXlBoR_kLhmJp4CDUBb8U6BWkNneIOEkteXP4wH69OgvI8h2Aq3Cufi_TD3huKkJ3FtYDMI47kWwh89IFhyfutypuvQTnf7R",alt:null})),(0,r.kt)("p",null,"Note that because we are checking the exact address, we only need to check to 0 offset. The value stored in memory is stored as hex."),(0,r.kt)("p",null,"The next instruction is an unconditional jump and it just jumps to clearing the eax register. The ",(0,r.kt)("inlineCode",{parentName:"p"},"popq")," instruction involves popping a value of the stack and reading it, and the return instruction sets this popped value to the current instruction pointer. In this case, it shows the execution of the program has been completed. To understand better about how an if statement work, you can check the corresponding C file in the same folder."),(0,r.kt)("p",null,"The following questions involve analysing the if2 binary."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"What is the value of var_8h before the popq and ret instructions?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"96")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"what is the value of var_ch before the popq and ret instructions?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"What is the value of var_4h before the popq and ret instructions?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"1")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"What operator is used to change the value of var_8h, input the symbol as your answer(symbols include +, -, *, /, &, |):")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"&")),(0,r.kt)("h2",{id:"task-5-loops"},"Task 5 Loops"),(0,r.kt)("p",null,"Usually two types of loops are used: for loops and while loops. The general format of a while loops is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"while(condition) {\n    Do-stuff-here\n    Change value used in condition\n}\n")),(0,r.kt)("p",null,"The general format of a for loop is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"for(initialise value: condition; change value used in condition) {\n    do-stuff-here\n}\n")),(0,r.kt)("p",null,"Let\u2019s start looking up loops by entering the loops folder, running r2 with the loops 1 file. After this, analyse everything, list the functions and disassemble the main function. "),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh4.googleusercontent.com/OKIkdD0MD_xvJ8zqJpR8LJBnffeOjeoWXRHFQ1uahwqmrfB-t6tctxc-8Nfm1t4gS_nwR61ekl1x4bVvY4mslLbjfaqbtKfs4onYHxaHr7dt1jAbfj59W7xdVtJOjAMXnqGFo67O",alt:null})),(0,r.kt)("p",null,"Let start of by setting a break point at the jmp instruction using the command:",(0,r.kt)("inlineCode",{parentName:"p"}," db address-of-instruction")),(0,r.kt)("p",null,"Doing this allows use to skip the first few lines of instructions, which as we saw using if statements, it just passing in values to local arguments(note that the constant showed by $0xa represents that value of 10 in hex). Once execution reaches the breakpoint at the jmp instruction, run ds to move to the next instruction. Since this is an unconditional jump, it will move to the cmpl instruction."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh6.googleusercontent.com/mMG7wWP3vWB59e_2EtZuRgl8b_g4PwYklXzn8SaKCL5zLHUZmbmQhnO6JBUEiZvWG5JBQPR2WQUmkZFA5arFafm88l_c2rhjILTlhf064o7wO9Zmg99eq6iqvoqHYdDMebmZuURM",alt:null})),(0,r.kt)("p",null,"Here the ",(0,r.kt)("inlineCode",{parentName:"p"},"cmpl")," instruction is trying to compare what\u2019s in the local argument var_ch with the value 8. To see what\u2019s in var_ch, check the start of the disassembled function and check the memory. In this case, it is ",(0,r.kt)("inlineCode",{parentName:"p"},"rbp-0xc")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh3.googleusercontent.com/KL9Y3euzWtQh-FqiylEiSpoEerjE8zHoetxHMqmbth5-mCw0ETwNubCaibWDXV7WIGo9IecXZPjFQ88xy-JC9dPkCTAFO-yBlRb5OG_Yy6jY87MFM-XqF1WI7PFzXDsXJgXIAaiI",alt:null})),(0,r.kt)("p",null,"And shows that it contains 4. The next instruction is a ",(0,r.kt)("inlineCode",{parentName:"p"},"jle")," which is going to check is the value is var-ch is less than or equal to 8. Since 4 is less than 8, it will jump to the ",(0,r.kt)("inlineCode",{parentName:"p"},"addl")," instruction. "),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://lh6.googleusercontent.com/W2rtR7Df_6PWd2FiKcixUJA92dPgYb3ISpwgdfA-ONMhfM_WpgrpRVziXBSjDy2fj3pWmHanGfr_Dhck7bIq9__lfH3IgGRJDl-PpRuCn761XBCWTRpaavCSHsTbthx_VTyx_kaL",alt:null})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"addl")," instruction will add 2 to the value of var-ch and continue to go to the ",(0,r.kt)("inlineCode",{parentName:"p"},"cmpl")," instruction. Since 2 was added to var_ch, var_ch will now contain 6 which is still less than 8, and it will jump back to the ",(0,r.kt)("inlineCode",{parentName:"p"},"addl")," instruction. This can be seeing by continuing execution using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ds")," statement. We know this is a loop because the ",(0,r.kt)("inlineCode",{parentName:"p"},"addl")," instruction is being executed more than once, and this is in combination with comparing the value of var_ch to 8. So we can infer the structure of the loop to be"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"while(var_ch < 8) {\n    var_ch = var_ch + 2\n}\n")),(0,r.kt)("p",null,"A quicker way to examine the loop would be to add a break point to ",(0,r.kt)("inlineCode",{parentName:"p"},"cmpl")," instruction and running ",(0,r.kt)("inlineCode",{parentName:"p"},"dc"),". Since this is a loop, the program will always break at the ",(0,r.kt)("inlineCode",{parentName:"p"},"cmpl")," instruction(because this instruction checks the condition before executing what is inside the loop). You can check the loop1.c file to see the structure of the loop! "),(0,r.kt)("p",null,"Use the loop2 binary to answer the following questions."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"What is the value of var_8h on the second iteration of the loop?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"5")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"What is the value of var_ch on the second iteration of the loop?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"What is the value of var_8h at the end of the program?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"2")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"What is the value of var_ch at the end of the program?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"0")),(0,r.kt)("h2",{id:"task-6-crackme1"},"Task 6 crackme1"),(0,r.kt)("p",null,"Go to the crackme folder and analyse the crackme1 binary. This binary checks if the user has a correct password, and this can be done by running the binary and entering the password."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"What is the password?")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"127.0.0.1")),(0,r.kt)("h2",{id:"task-7-crackme2"},"Task 7 crackme2"),(0,r.kt)("p",null,"Analyse the crackme2 binary and try find the correct password, as with the previous question."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"What is the correct password?")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/home/tryhackme/install-files/secret.txt\nkali@kali:~/CTFs/tryhackme/Intro to x86-64$ echo vs3curepwd | rev\ndwperuc3sv\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dwperuc3sv")))}m.isMDXComponent=!0}}]);