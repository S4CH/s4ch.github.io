<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Novel approach to tackle UAF Bugs in the Linux Kernel | CyFun</title><meta name=keywords content="linux-kernel,memory-management,uaf,vulnerability-mitigation,allocators"><meta name=description content="Analysis of dedicated bucket allocators as a novel mitigation technique for use-after-free vulnerabilities in the Linux kernel."><meta name=author content><link rel=canonical href=https://s4ch.github.io/research/bucket-allocators/><link crossorigin=anonymous href=/assets/css/stylesheet.35b906a90813b2766df33de5f84bf4610918496b745304c45e387646ed743bea.css integrity="sha256-NbkGqQgTsnZt8z3l+Ev0YQkYSWt0UwTEXjh2Ru10O+o=" rel="preload stylesheet" as=style><link rel=icon href=https://s4ch.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s4ch.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s4ch.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s4ch.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s4ch.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://s4ch.github.io/research/bucket-allocators/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Novel approach to tackle UAF Bugs in the Linux Kernel"><meta property="og:description" content="Analysis of dedicated bucket allocators as a novel mitigation technique for use-after-free vulnerabilities in the Linux kernel."><meta property="og:type" content="article"><meta property="og:url" content="https://s4ch.github.io/research/bucket-allocators/"><meta property="article:section" content="research"><meta property="article:published_time" content="2024-09-15T06:30:05+00:00"><meta property="article:modified_time" content="2025-08-18T19:06:49+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Novel approach to tackle UAF Bugs in the Linux Kernel"><meta name=twitter:description content="Analysis of dedicated bucket allocators as a novel mitigation technique for use-after-free vulnerabilities in the Linux kernel."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Research","item":"https://s4ch.github.io/research/"},{"@type":"ListItem","position":2,"name":"Novel approach to tackle UAF Bugs in the Linux Kernel","item":"https://s4ch.github.io/research/bucket-allocators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Novel approach to tackle UAF Bugs in the Linux Kernel","name":"Novel approach to tackle UAF Bugs in the Linux Kernel","description":"Analysis of dedicated bucket allocators as a novel mitigation technique for use-after-free vulnerabilities in the Linux kernel.","keywords":["linux-kernel","memory-management","uaf","vulnerability-mitigation","allocators"],"articleBody":"Hi, kernel and sec enthusiasts! It’s been a while since my last post(2022), but I’ve got something juicy for you today. We are going to dive into an exciting new proposal that aims to bolster the Linux kernel’s defenses against those persistent use-after-free (UAF) vulnerabilities. Grab your favorite beverage or drink(Try Amul Kool once, Thank me later), because we’re about to get our hands dirty with some kernel internals!\nThe Persistent Threat of UAF Vulnerabilities If you’ve been in the low-level security for a while, you’re probably sick of hearing about UAF vulnerabilities. But for those who need a refresher, UAFs occur when a program continues to use a pointer to memory after it’s been freed. This can lead to all sorts of fun exploitation scenarios, especially in kernel-land where the stakes are highest.\nThe tricky thing about UAFs is that they’re not just a coding error – they’re a fundamental weakness in how we manage memory. And in the Linux kernel, where performance is king and memory management is complex, they’ve been a persistent thorn in our side.\nDedicated Bucket Allocators Recently, Kees Cook (if you’re not following his work, you should be) proposed a new mitigation technique that’s got me pretty excited. The core idea? Dedicated bucket allocators for sensitive kernel subsystems.\nNow, I know what you’re thinking, Another allocator? Didn’t we just get done with SLUB?\nThe basic idea is to create isolated pools of memory for specific kernel subsystems, especially those that deal with user-controlled data. By segregating these allocations, we make it much harder for attackers to reliably exploit UAF bugs through techniques like heap spraying or type confusion attacks.\nLet’s look at the core of this new API:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 struct kmem_buckets { struct kmem_cache *caches[ARRAY_SIZE(kmalloc_caches[KMALLOC_NORMAL])]; }; // function to create kmem_buckets object // takes name, align, flags, offset, size and a constructor function struct kmem_buckets * kmem_buckets_create(const char *name, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*ctor)(void *)) { struct kmem_buckets *b; // pointer to our kmem_buckets object int idx; // allocate memory for kmem_buckets and zero it out b = kmem_cache_alloc(kmem_buckets_cache, GFP_KERNEL|__GFP_ZERO); // check if allocation failed, and warn if it did if (WARN_ON(!b)) return NULL; // bail out if no memory // loop through the kmalloc_caches array for (idx = 0; idx \u003c ARRAY_SIZE(kmalloc_caches[KMALLOC_NORMAL]); idx++) { char *short_size, *cache_name; unsigned int size; // skip empty cache slots if (!kmalloc_caches[KMALLOC_NORMAL][idx]) continue; // get the object size from the current cache size = kmalloc_caches[KMALLOC_NORMAL][idx]-\u003eobject_size; if (!size) continue; // if size is 0, move on // find the '-' in the cache name to separate it out short_size = strchr(kmalloc_caches[KMALLOC_NORMAL][idx]-\u003ename, '-'); // if no '-' found, something's weird, so bail if (WARN_ON(!short_size)) goto fail; // create a new cache name like \"name-suffix\" cache_name = kasprintf(GFP_KERNEL, \"%s-%s\", name, short_size + 1); // check if name creation failed if (WARN_ON(!cache_name)) goto fail; // create the actual kmem cache and store it b-\u003ecaches[idx] = kmem_cache_create_usercopy(cache_name, size, align, flags, useroffset, min(size - useroffset, usersize), ctor); // free the temporary cache_name string kfree(cache_name); // if cache creation failed, warn and bail if (WARN_ON(!b-\u003ecaches[idx])) goto fail; } // all good, return the bucket pointer return b; fail: // something broke, cleanup any created caches for (idx = 0; idx \u003c ARRAY_SIZE(kmalloc_caches[KMALLOC_NORMAL]); idx++) { if (b-\u003ecaches[idx]) { // free the cache name and destroy the cache kfree(b-\u003ecaches[idx]-\u003ename); kmem_cache_destroy(b-\u003ecaches[idx]); } } // free the bucket itself and return NULL to indicate failure kfree(b); return NULL; } What’s happening here is that we’re creating a whole set of caches, mirroring the usual kmalloc sizes, but dedicated to a specific use case. It’s like giving each subsystem its own private kmalloc pool.\nPutting It to Work So where might we use this shiny new toy? Kees’s patch set targets a few juicy areas:\nIPC Message Queues: The msg_msg structure has been a favorite target for exploits. By giving it its own memory bucket, we make it a lot harder to pull off the kind of tricks that have made it so exploitable in the past.\nExtended Attributes (xattr): The xattr syscalls have been another common vector for attacks, largely because they involve user-controlled allocation sizes. Isolating these allocations adds an extra layer of protection.\nUser Memory Duplication: The memdup_user() function, used in various syscalls including prctl(), is another area where attackers have found something to play with. Again, dedicated buckets to the rescue.\nHere’s a snippet of how it looks in practice, for the xattr case:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static __always_inline __alloc_size(2) void *kmem_buckets_alloc(struct kmem_buckets *b, size_t size, gfp_t flags) { unsigned int index; // if the size is too big for normal caches, fall back to large kmalloc if (size \u003e KMALLOC_MAX_CACHE_SIZE) return kmalloc_large(size, flags); // warn if bucket is null, bail early if it is if (WARN_ON_ONCE(!b)) return NULL; // get the cache index for the given size index = kmalloc_index(size); // warn once if the cache for the index is missing, and just use kmalloc as a fallback if (WARN_ONCE(!b-\u003ecaches[index], \"missing cache for size %zu (index %d)\\n\", size, index)) return kmalloc(size, flags); // use the cache if everything checks out and trace the allocation return kmalloc_trace(b-\u003ecaches[index], flags, size); } The Good, The Bad, and The Grey or geeky Now, I love a good security enhancement as much as the next paranoid sysadmin, but let’s talk about the implications of this approach.\nThe Good:\nIt makes exploiting UAFs significantly harder by isolating potential targets. It’s a relatively simple concept that builds on existing kernel mechanisms. It allows for fine-grained control over memory allocation patterns. The Bad:\nThere’s potential for increased memory fragmentation. It adds another layer of complexity to the kernel’s already complex memory management. There might be a performance hit (though likely minimal). The Grey: For those of us who love to tinker around, this opens up some interesting possibilities. Imagine combining this with memory tagging or even more aggressive randomization techniques. The possibilities for frustrating attackers are endless!\nWrapping Up So there you have it, folks. A new approach in our ongoing efforts against UAF vulnerabilities. Is it a silver bullet? Of course not. But it’s a clever approach that addresses a fundamental weakness in how we’ve been managing memory.\nWhat I really love about this proposal is how it showcases the ongoing innovation in kernel security. We’re not just patching individual vulnerabilities; we’re rethinking core mechanisms to make the entire system more resilient.\nFor those of you who want to dig deeper, I highly recommend reading Kees’s full patch set. And if you’re feeling adventurous, why not try implementing this in your own kernel modules? There’s no better way to understand kernel security than by getting your hands dirty.\nUntil next time, see yaa!\nReferences Introduce dedicated bucket allocator by Kees Cook\nP.S. If any of you manage to break this new allocator in an interesting way, drop me a line on X or discord\n","wordCount":"1250","inLanguage":"en","datePublished":"2024-09-15T06:30:05Z","dateModified":"2025-08-18T19:06:49+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://s4ch.github.io/research/bucket-allocators/"},"publisher":{"@type":"Organization","name":"CyFun","logo":{"@type":"ImageObject","url":"https://s4ch.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://s4ch.github.io/ accesskey=h title="CyFun (Alt + H)">CyFun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://s4ch.github.io/about/ title=About><span>About</span></a></li><li><a href=https://s4ch.github.io/contact/ title=Contact><span>Contact</span></a></li><li><a href=https://s4ch.github.io/research/ title=Research><span>Research</span></a></li><li><a href=https://s4ch.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://s4ch.github.io/writeups/ title=Writeups><span>Writeups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Novel approach to tackle UAF Bugs in the Linux Kernel</h1><div class=post-meta><span title='2024-09-15 06:30:05 +0000 UTC'>September 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1250 words&nbsp;·&nbsp;
<a href=https://s4ch.github.io/tags/linux-kernel/ class=post-tag title=linux-kernel>linux-kernel</a>
,
<a href=https://s4ch.github.io/tags/memory-management/ class=post-tag title=memory-management>memory-management</a>
,
<a href=https://s4ch.github.io/tags/uaf/ class=post-tag title=uaf>uaf</a>
,
<a href=https://s4ch.github.io/tags/vulnerability-mitigation/ class=post-tag title=vulnerability-mitigation>vulnerability-mitigation</a>
,
<a href=https://s4ch.github.io/tags/allocators/ class=post-tag title=allocators>allocators</a>
&nbsp;·&nbsp;
<a href=https://s4ch.github.io/categories/research/ class=post-tag title=research>research</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-persistent-threat-of-uaf-vulnerabilities>The Persistent Threat of UAF Vulnerabilities</a></li><li><a href=#dedicated-bucket-allocators>Dedicated Bucket Allocators</a></li><li><a href=#putting-it-to-work>Putting It to Work</a></li><li><a href=#the-good-the-bad-and-the-grey-or-geeky>The Good, The Bad, and The Grey or geeky</a></li><li><a href=#wrapping-up>Wrapping Up</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>Hi, kernel and sec enthusiasts! It&rsquo;s been a while since my last post(2022), but I&rsquo;ve got something juicy for you today. We are going to dive into an exciting new proposal that aims to bolster the Linux kernel&rsquo;s defenses against those persistent use-after-free (UAF) vulnerabilities. Grab your favorite beverage or drink(Try Amul Kool once, Thank me later), because we&rsquo;re about to get our hands dirty with some kernel internals!</p><h2 id=the-persistent-threat-of-uaf-vulnerabilities>The Persistent Threat of UAF Vulnerabilities<a hidden class=anchor aria-hidden=true href=#the-persistent-threat-of-uaf-vulnerabilities>#</a></h2><p>If you&rsquo;ve been in the low-level security for a while, you&rsquo;re probably sick of hearing about UAF vulnerabilities. But for those who need a refresher, UAFs occur when a program continues to use a pointer to memory after it&rsquo;s been freed. This can lead to all sorts of fun exploitation scenarios, especially in kernel-land where the stakes are highest.</p><p>The tricky thing about UAFs is that they&rsquo;re not just a coding error – they&rsquo;re a fundamental weakness in how we manage memory. And in the Linux kernel, where performance is king and memory management is complex, they&rsquo;ve been a persistent thorn in our side.</p><h2 id=dedicated-bucket-allocators>Dedicated Bucket Allocators<a hidden class=anchor aria-hidden=true href=#dedicated-bucket-allocators>#</a></h2><p>Recently, Kees Cook (if you&rsquo;re not following his work, you should be) proposed a new mitigation technique that&rsquo;s got me pretty excited. The core idea? Dedicated bucket allocators for sensitive kernel subsystems.</p><p>Now, I know what you&rsquo;re thinking, Another allocator? Didn&rsquo;t we just get done with SLUB?</p><p>The basic idea is to create isolated pools of memory for specific kernel subsystems, especially those that deal with user-controlled data.
By segregating these allocations, we make it much harder for attackers to reliably exploit UAF bugs through techniques like heap spraying or type confusion attacks.</p><p>Let&rsquo;s look at the core of this new API:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>struct</span> <span class=n>kmem_buckets</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>struct</span> <span class=n>kmem_cache</span> <span class=o>*</span><span class=n>caches</span><span class=p>[</span><span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>])];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>function</span> <span class=n>to</span> <span class=n>create</span> <span class=n>kmem_buckets</span> <span class=n>object</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>takes</span> <span class=n>name</span><span class=p>,</span> <span class=n>align</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>size</span> <span class=ow>and</span> <span class=n>a</span> <span class=n>constructor</span> <span class=n>function</span>
</span></span><span class=line><span class=cl><span class=n>struct</span> <span class=n>kmem_buckets</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=n>kmem_buckets_create</span><span class=p>(</span><span class=k>const</span> <span class=n>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=n>unsigned</span> <span class=ne>int</span> <span class=n>align</span><span class=p>,</span> <span class=n>slab_flags_t</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>unsigned</span> <span class=ne>int</span> <span class=n>useroffset</span><span class=p>,</span> <span class=n>unsigned</span> <span class=ne>int</span> <span class=n>usersize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>void</span> <span class=p>(</span><span class=o>*</span><span class=n>ctor</span><span class=p>)(</span><span class=n>void</span> <span class=o>*</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>struct</span> <span class=n>kmem_buckets</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>  <span class=o>//</span> <span class=n>pointer</span> <span class=n>to</span> <span class=n>our</span> <span class=n>kmem_buckets</span> <span class=n>object</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>allocate</span> <span class=n>memory</span> <span class=k>for</span> <span class=n>kmem_buckets</span> <span class=ow>and</span> <span class=n>zero</span> <span class=n>it</span> <span class=n>out</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>kmem_cache_alloc</span><span class=p>(</span><span class=n>kmem_buckets_cache</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=o>|</span><span class=n>__GFP_ZERO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>check</span> <span class=k>if</span> <span class=n>allocation</span> <span class=n>failed</span><span class=p>,</span> <span class=ow>and</span> <span class=n>warn</span> <span class=k>if</span> <span class=n>it</span> <span class=n>did</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>WARN_ON</span><span class=p>(</span><span class=o>!</span><span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>NULL</span><span class=p>;</span>  <span class=o>//</span> <span class=n>bail</span> <span class=n>out</span> <span class=k>if</span> <span class=n>no</span> <span class=n>memory</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>loop</span> <span class=n>through</span> <span class=n>the</span> <span class=n>kmalloc_caches</span> <span class=n>array</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>]);</span> <span class=n>idx</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=o>*</span><span class=n>short_size</span><span class=p>,</span> <span class=o>*</span><span class=n>cache_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>unsigned</span> <span class=ne>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>skip</span> <span class=n>empty</span> <span class=n>cache</span> <span class=n>slots</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>][</span><span class=n>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>get</span> <span class=n>the</span> <span class=n>object</span> <span class=n>size</span> <span class=n>from</span> <span class=n>the</span> <span class=n>current</span> <span class=n>cache</span>
</span></span><span class=line><span class=cl>        <span class=n>size</span> <span class=o>=</span> <span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>][</span><span class=n>idx</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>object_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>  <span class=o>//</span> <span class=k>if</span> <span class=n>size</span> <span class=n>is</span> <span class=mi>0</span><span class=p>,</span> <span class=n>move</span> <span class=n>on</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>find</span> <span class=n>the</span> <span class=s1>&#39;-&#39;</span> <span class=ow>in</span> <span class=n>the</span> <span class=n>cache</span> <span class=n>name</span> <span class=n>to</span> <span class=n>separate</span> <span class=n>it</span> <span class=n>out</span>
</span></span><span class=line><span class=cl>        <span class=n>short_size</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>][</span><span class=n>idx</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=s1>&#39;-&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=k>if</span> <span class=n>no</span> <span class=s1>&#39;-&#39;</span> <span class=n>found</span><span class=p>,</span> <span class=n>something</span><span class=s1>&#39;s weird, so bail</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>WARN_ON</span><span class=p>(</span><span class=o>!</span><span class=n>short_size</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>create</span> <span class=n>a</span> <span class=n>new</span> <span class=n>cache</span> <span class=n>name</span> <span class=n>like</span> <span class=s2>&#34;name-suffix&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>cache_name</span> <span class=o>=</span> <span class=n>kasprintf</span><span class=p>(</span><span class=n>GFP_KERNEL</span><span class=p>,</span> <span class=s2>&#34;</span><span class=si>%s</span><span class=s2>-</span><span class=si>%s</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>short_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>check</span> <span class=k>if</span> <span class=n>name</span> <span class=n>creation</span> <span class=n>failed</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>WARN_ON</span><span class=p>(</span><span class=o>!</span><span class=n>cache_name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>create</span> <span class=n>the</span> <span class=n>actual</span> <span class=n>kmem</span> <span class=n>cache</span> <span class=ow>and</span> <span class=n>store</span> <span class=n>it</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>caches</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>kmem_cache_create_usercopy</span><span class=p>(</span><span class=n>cache_name</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>align</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>useroffset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=nb>min</span><span class=p>(</span><span class=n>size</span> <span class=o>-</span> <span class=n>useroffset</span><span class=p>,</span> <span class=n>usersize</span><span class=p>),</span> <span class=n>ctor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>free</span> <span class=n>the</span> <span class=n>temporary</span> <span class=n>cache_name</span> <span class=n>string</span>
</span></span><span class=line><span class=cl>        <span class=n>kfree</span><span class=p>(</span><span class=n>cache_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=k>if</span> <span class=n>cache</span> <span class=n>creation</span> <span class=n>failed</span><span class=p>,</span> <span class=n>warn</span> <span class=ow>and</span> <span class=n>bail</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>WARN_ON</span><span class=p>(</span><span class=o>!</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>caches</span><span class=p>[</span><span class=n>idx</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>            <span class=n>goto</span> <span class=n>fail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>all</span> <span class=n>good</span><span class=p>,</span> <span class=k>return</span> <span class=n>the</span> <span class=n>bucket</span> <span class=n>pointer</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>something</span> <span class=n>broke</span><span class=p>,</span> <span class=n>cleanup</span> <span class=n>any</span> <span class=n>created</span> <span class=n>caches</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>kmalloc_caches</span><span class=p>[</span><span class=n>KMALLOC_NORMAL</span><span class=p>]);</span> <span class=n>idx</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>caches</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>//</span> <span class=n>free</span> <span class=n>the</span> <span class=n>cache</span> <span class=n>name</span> <span class=ow>and</span> <span class=n>destroy</span> <span class=n>the</span> <span class=n>cache</span>
</span></span><span class=line><span class=cl>            <span class=n>kfree</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>caches</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>kmem_cache_destroy</span><span class=p>(</span><span class=n>b</span><span class=o>-&gt;</span><span class=n>caches</span><span class=p>[</span><span class=n>idx</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>free</span> <span class=n>the</span> <span class=n>bucket</span> <span class=n>itself</span> <span class=ow>and</span> <span class=k>return</span> <span class=n>NULL</span> <span class=n>to</span> <span class=n>indicate</span> <span class=n>failure</span>
</span></span><span class=line><span class=cl>    <span class=n>kfree</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>What&rsquo;s happening here is that we&rsquo;re creating a whole set of caches, mirroring the usual kmalloc sizes, but dedicated to a specific use case. It&rsquo;s like giving each subsystem its own private kmalloc pool.</p><h2 id=putting-it-to-work>Putting It to Work<a hidden class=anchor aria-hidden=true href=#putting-it-to-work>#</a></h2><p>So where might we use this shiny new toy? Kees&rsquo;s patch set targets a few juicy areas:</p><ol><li><p><strong>IPC Message Queues</strong>: The <code>msg_msg</code> structure has been a favorite target for exploits. By giving it its own memory bucket, we make it a lot harder to pull off the kind of tricks that have made it so exploitable in the past.</p></li><li><p><strong>Extended Attributes (xattr)</strong>: The xattr syscalls have been another common vector for attacks, largely because they involve user-controlled allocation sizes. Isolating these allocations adds an extra layer of protection.</p></li><li><p><strong>User Memory Duplication</strong>: The <code>memdup_user()</code> function, used in various syscalls including <code>prctl()</code>, is another area where attackers have found something to play with. Again, dedicated buckets to the rescue.</p></li></ol><p>Here&rsquo;s a snippet of how it looks in practice, for the xattr case:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static __always_inline __alloc_size(2)
</span></span><span class=line><span class=cl>void *kmem_buckets_alloc(struct kmem_buckets *b, size_t size, gfp_t flags)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    unsigned int index;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // if the size is too big for normal caches, fall back to large kmalloc
</span></span><span class=line><span class=cl>    if (size &gt; KMALLOC_MAX_CACHE_SIZE)
</span></span><span class=line><span class=cl>        return kmalloc_large(size, flags);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    // warn if bucket is null, bail early if it is
</span></span><span class=line><span class=cl>    if (WARN_ON_ONCE(!b))
</span></span><span class=line><span class=cl>        return NULL;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // get the cache index for the given size
</span></span><span class=line><span class=cl>    index = kmalloc_index(size);
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    // warn once if the cache for the index is missing, and just use kmalloc as a fallback
</span></span><span class=line><span class=cl>    if (WARN_ONCE(!b-&gt;caches[index],
</span></span><span class=line><span class=cl>                  &#34;missing cache for size %zu (index %d)\n&#34;, size, index))
</span></span><span class=line><span class=cl>        return kmalloc(size, flags);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // use the cache if everything checks out and trace the allocation
</span></span><span class=line><span class=cl>    return kmalloc_trace(b-&gt;caches[index], flags, size);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h2 id=the-good-the-bad-and-the-grey-or-geeky>The Good, The Bad, and The Grey or geeky<a hidden class=anchor aria-hidden=true href=#the-good-the-bad-and-the-grey-or-geeky>#</a></h2><p>Now, I love a good security enhancement as much as the next paranoid sysadmin, but let&rsquo;s talk about the implications of this approach.</p><p><strong>The Good:</strong></p><ul><li>It makes exploiting UAFs significantly harder by isolating potential targets.</li><li>It&rsquo;s a relatively simple concept that builds on existing kernel mechanisms.</li><li>It allows for fine-grained control over memory allocation patterns.</li></ul><p><strong>The Bad:</strong></p><ul><li>There&rsquo;s potential for increased memory fragmentation.</li><li>It adds another layer of complexity to the kernel&rsquo;s already complex memory management.</li><li>There might be a performance hit (though likely minimal).</li></ul><p><strong>The Grey:</strong>
For those of us who love to tinker around, this opens up some interesting possibilities. Imagine combining this with memory tagging or even more aggressive randomization techniques. The possibilities for frustrating attackers are endless!</p><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>So there you have it, folks. A new approach in our ongoing efforts against UAF vulnerabilities. Is it a silver bullet? Of course not. But it&rsquo;s a clever approach that addresses a fundamental weakness in how we&rsquo;ve been managing memory.</p><p>What I really love about this proposal is how it showcases the ongoing innovation in kernel security. We&rsquo;re not just patching individual vulnerabilities; we&rsquo;re rethinking core mechanisms to make the entire system more resilient.</p><p>For those of you who want to dig deeper, I highly recommend reading Kees&rsquo;s full patch set. And if you&rsquo;re feeling adventurous, why not try implementing this in your own kernel modules? There&rsquo;s no better way to understand kernel security than by getting your hands dirty.</p><p>Until next time, see yaa!</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://lore.kernel.org/lkml/202403041502.28477148C0@keescook/T/>Introduce dedicated bucket allocator by Kees Cook</a></p><p><em><strong>P.S.</strong></em> If any of you manage to break this new allocator in an interesting way, drop me a line on <a href=https://www.x.com/cy5un/>X</a> or <a href=https://discord.com/users/346443596641075200>discord</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://s4ch.github.io/tags/linux-kernel/>Linux-Kernel</a></li><li><a href=https://s4ch.github.io/tags/memory-management/>Memory-Management</a></li><li><a href=https://s4ch.github.io/tags/uaf/>Uaf</a></li><li><a href=https://s4ch.github.io/tags/vulnerability-mitigation/>Vulnerability-Mitigation</a></li><li><a href=https://s4ch.github.io/tags/allocators/>Allocators</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://s4ch.github.io/>CyFun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>